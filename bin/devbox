#!/bin/bash
set -euo pipefail

# Devbox CLI - Manage isolated, authenticated development containers
# Version: 0.1.0

# Constants
readonly DEVBOX_IMAGE="devbox-base:latest"
readonly DEVBOX_VOLUME="devbox-credentials"
readonly CONTAINER_PREFIX="devbox-"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}INFO:${NC} $*"
}

log_success() {
    echo -e "${GREEN}✓${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $*"
}

log_error() {
    echo -e "${RED}✗${NC} $*" >&2
}

# Check if Docker is running
check_docker() {
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker is not running or not accessible"
        log_error "Please start Docker and try again"
        exit 1
    fi
}

# Build the base image if it doesn't exist
ensure_image() {
    if ! docker image inspect "$DEVBOX_IMAGE" >/dev/null 2>&1; then
        log_info "Building devbox base image..."
        if ! docker build -t "$DEVBOX_IMAGE" "$PROJECT_ROOT/docker"; then
            log_error "Failed to build devbox base image"
            exit 1
        fi
        log_success "Base image built successfully"
    fi
}

# Resolve container name or ID to full container ID
resolve_container() {
    local name_or_id="$1"
    local container_id

    # First try exact name match with prefix
    if container_id=$(docker ps -aq --filter "name=^${CONTAINER_PREFIX}${name_or_id}$" 2>/dev/null) && [[ -n "$container_id" ]]; then
        echo "$container_id"
        return 0
    fi

    # Try partial ID match among devbox containers
    if container_id=$(docker ps -aq --filter "name=^${CONTAINER_PREFIX}" | xargs -I {} docker inspect --format '{{.Id}} {{.Name}}' {} 2>/dev/null | grep "^$name_or_id" | head -1 | cut -d' ' -f1) && [[ -n "$container_id" ]]; then
        echo "$container_id"
        return 0
    fi

    # Not found
    return 1
}

# Usage/help function
usage() {
    cat << EOF
Devbox - Manage isolated, authenticated development containers

USAGE:
    devbox <command> [options]

COMMANDS:
    init                    One-time setup: authenticate GitHub CLI and Claude Code
    create <name> <repo>    Create and start a new container instance
    list                    List all devbox containers with status
    attach <name|id>        Attach to a running container's shell
    stop <name|id>          Stop a container (keeps state)
    start <name|id>         Start a stopped container
    rm <name|id>            Remove a container
    logs <name|id>          View container logs
    exec <name|id> <cmd>    Execute a command in a running container
    ports <name|id>         Show port mappings for a container
    help                    Show this help message

INIT OPTIONS:
    --bedrock              Skip Claude OAuth, configure for Bedrock mode
    --import-aws           Import existing AWS credentials from ~/.aws

CREATE OPTIONS:
    --port, -p <host:container>  Port mapping (repeatable)
    --bedrock              Use AWS Bedrock for Claude (sets CLAUDE_CODE_USE_BEDROCK=1)
    --aws-profile <profile>  AWS profile name

RM OPTIONS:
    --force                Force remove a running container

LOGS OPTIONS:
    -f, --follow           Follow log output

EXAMPLES:
    # First-time setup (OAuth mode)
    devbox init

    # First-time setup (Bedrock mode)
    devbox init --bedrock --import-aws

    # Create container with port mapping
    devbox create myapp git@github.com:org/repo.git --port 3000:3000

    # Create container for Bedrock
    devbox create myapp git@github.com:org/repo.git --bedrock --aws-profile prod

    # List containers
    devbox list

    # Attach to container
    devbox attach myapp

    # Execute command in container
    devbox exec myapp gh pr list

EOF
}

# Command implementations
cmd_init() {
    local bedrock_mode=false
    local import_aws=false
    local dry_run=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --bedrock)
                bedrock_mode=true
                shift
                ;;
            --import-aws)
                import_aws=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --help|-h)
                cat << EOF
devbox init - One-time setup: authenticate GitHub CLI and Claude Code

USAGE:
    devbox init [options]

OPTIONS:
    --bedrock              Skip Claude OAuth, configure for Bedrock mode
    --import-aws           Import existing AWS credentials from ~/.aws
    --help, -h             Show this help message

DESCRIPTION:
    Performs initial setup by creating the credential volume and running
    the authentication flow for GitHub CLI and Claude Code. Credentials
    are stored in a Docker volume and shared across all devbox containers.

EXAMPLES:
    # Standard setup with Claude OAuth
    devbox init

    # Setup for AWS Bedrock mode
    devbox init --bedrock --import-aws

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                log_error "Unexpected argument: $1"
                return 1
                ;;
        esac
    done

    # Dry run mode for testing
    if [[ "$dry_run" == true ]]; then
        log_info "Dry run mode enabled"
        if [[ "$bedrock_mode" == true ]]; then
            log_info "Bedrock mode enabled"
        fi
        if [[ "$import_aws" == true ]]; then
            log_info "AWS import enabled"
        fi
        return 0
    fi

    log_info "Starting devbox initialization..."

    # Check if credential volume already exists
    if docker volume inspect "$DEVBOX_VOLUME" >/dev/null 2>&1; then
        log_warning "Credential volume '$DEVBOX_VOLUME' already exists"
        log_info "Initialization may overwrite existing credentials"

        # Prompt for confirmation
        read -r -p "Continue with initialization? [y/N] " response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_info "Initialization cancelled"
            return 0
        fi
    else
        log_info "Creating credential volume '$DEVBOX_VOLUME'..."
        if ! docker volume create "$DEVBOX_VOLUME" >/dev/null 2>&1; then
            log_error "Failed to create credential volume"
            return 1
        fi
        log_success "Credential volume created successfully"
    fi

    # Prepare environment variables for the init container
    local init_env=""
    if [[ "$bedrock_mode" == true ]]; then
        init_env="$init_env -e BEDROCK_MODE=true"
    fi
    if [[ "$import_aws" == true ]]; then
        init_env="$init_env -e IMPORT_AWS=true"
    fi

    # Mount host ~/.aws directory if importing AWS credentials
    local aws_mount=""
    if [[ "$import_aws" == true ]] && [[ -d "$HOME/.aws" ]]; then
        aws_mount="-v $HOME/.aws:/host-aws:ro"
    fi

    log_info "Starting authentication container..."

    # Run the initialization container
    local container_cmd="docker run --rm -it \
        -v $DEVBOX_VOLUME:/devbox-credentials \
        $aws_mount \
        $init_env \
        $DEVBOX_IMAGE \
        /init-credentials.sh"

    log_info "Running: $container_cmd"

    if eval "$container_cmd"; then
        log_success "Devbox initialization completed successfully!"
        echo
        if [[ "$bedrock_mode" == true ]]; then
            log_info "Mode: AWS Bedrock"
            log_info "Claude Code will use AWS credentials for authentication"
        else
            log_info "Mode: Claude OAuth"
            log_info "Claude Code will use OAuth tokens for authentication"
        fi
        echo
        log_info "You can now create containers with: devbox create <name> <repo>"
    else
        log_error "Initialization failed"
        return 1
    fi
}

cmd_create() {
    log_error "Command 'create' not yet implemented"
    exit 1
}

cmd_list() {
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat << EOF
devbox list - List all devbox containers with status

USAGE:
    devbox list [options]

OPTIONS:
    --help, -h             Show this help message

DESCRIPTION:
    Lists all devbox containers with their current status, repository,
    port mappings, and authentication mode. Shows containers in both
    running and stopped states.

EXAMPLES:
    # List all containers
    devbox list

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                log_error "Unexpected argument: $1"
                return 1
                ;;
        esac
    done

    # Get all devbox containers (both running and stopped)
    local containers
    containers=$(docker ps -a --filter "name=^${CONTAINER_PREFIX}" --format "{{.ID}}\t{{.Names}}\t{{.Status}}" 2>/dev/null || true)

    if [[ -z "$containers" ]]; then
        log_info "No devbox containers found"
        echo
        echo "Create your first container with:"
        echo "  devbox create <name> <repo-url>"
        return 0
    fi

    # Print table header
    printf "%-12s %-10s %-10s %-35s %-15s %s\n" "NAME" "ID" "STATUS" "REPO" "PORTS" "MODE"
    printf "%-12s %-10s %-10s %-35s %-15s %s\n" "----" "--" "------" "----" "-----" "----"

    # Process each container
    while IFS=$'\t' read -r container_id container_name status; do
        # Extract container name without prefix
        # Handle both regular devbox containers and test containers
        local display_name="$container_name"
        if [[ "$container_name" == devbox-test-* ]]; then
            display_name="${container_name#devbox-test-}"
        elif [[ "$container_name" == devbox-* ]]; then
            display_name="${container_name#devbox-}"
        fi

        # Get short ID
        local short_id="${container_id:0:8}"

        # Determine simple status
        local simple_status="exited"
        if [[ "$status" == *"Up"* ]]; then
            simple_status="running"
        fi

        # Get container labels
        local repo mode ports
        repo=$(docker inspect --format '{{index .Config.Labels "devbox.repo"}}' "$container_id" 2>/dev/null || echo "unknown")
        mode=$(docker inspect --format '{{index .Config.Labels "devbox.mode"}}' "$container_id" 2>/dev/null || echo "oauth")
        ports=$(docker inspect --format '{{index .Config.Labels "devbox.ports"}}' "$container_id" 2>/dev/null || echo "")

        # Handle empty ports
        if [[ -z "$ports" ]] || [[ "$ports" == "<no value>" ]]; then
            ports="-"
        fi

        # Handle unknown/missing values
        if [[ "$repo" == "<no value>" ]]; then
            repo="unknown"
        fi
        if [[ "$mode" == "<no value>" ]]; then
            mode="oauth"
        fi

        # Print container row
        printf "%-12s %-10s %-10s %-35s %-15s %s\n" \
            "$display_name" "$short_id" "$simple_status" "$repo" "$ports" "$mode"

    done <<< "$containers"
}

cmd_attach() {
    log_error "Command 'attach' not yet implemented"
    exit 1
}

cmd_stop() {
    log_error "Command 'stop' not yet implemented"
    exit 1
}

cmd_start() {
    log_error "Command 'start' not yet implemented"
    exit 1
}

cmd_rm() {
    log_error "Command 'rm' not yet implemented"
    exit 1
}

cmd_logs() {
    log_error "Command 'logs' not yet implemented"
    exit 1
}

cmd_exec() {
    log_error "Command 'exec' not yet implemented"
    exit 1
}

cmd_ports() {
    log_error "Command 'ports' not yet implemented"
    exit 1
}

# Main command dispatcher
main() {
    # Check for help first
    if [[ $# -eq 0 ]] || [[ "$1" == "help" ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
        usage
        exit 0
    fi

    # Check Docker is available (skip for help-only commands)
    check_docker

    # Ensure base image exists (skip for non-container commands)
    if [[ "$1" != "help" ]]; then
        ensure_image
    fi

    # Dispatch commands
    case "$1" in
        init)
            shift
            cmd_init "$@"
            ;;
        create)
            shift
            cmd_create "$@"
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        attach)
            shift
            cmd_attach "$@"
            ;;
        stop)
            shift
            cmd_stop "$@"
            ;;
        start)
            shift
            cmd_start "$@"
            ;;
        rm)
            shift
            cmd_rm "$@"
            ;;
        logs)
            shift
            cmd_logs "$@"
            ;;
        exec)
            shift
            cmd_exec "$@"
            ;;
        ports)
            shift
            cmd_ports "$@"
            ;;
        *)
            log_error "Unknown command: $1"
            echo
            usage
            exit 1
            ;;
    esac
}

# Entry point
main "$@"