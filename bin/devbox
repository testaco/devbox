#!/bin/bash
set -euo pipefail

# Devbox CLI - Manage isolated, authenticated development containers
# Version: 0.1.0

# Constants
readonly DEVBOX_IMAGE="devbox-base:latest"
readonly DEVBOX_VOLUME="devbox-credentials"
readonly CONTAINER_PREFIX="devbox-"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}INFO:${NC} $*"
}

log_success() {
    echo -e "${GREEN}✓${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $*"
}

log_error() {
    echo -e "${RED}✗${NC} $*" >&2
}

# Check if Docker is running
check_docker() {
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker is not running or not accessible"
        log_error "Please start Docker and try again"
        exit 1
    fi
}

# Build the base image if it doesn't exist
ensure_image() {
    if ! docker image inspect "$DEVBOX_IMAGE" >/dev/null 2>&1; then
        log_info "Building devbox base image..."
        if ! docker build -t "$DEVBOX_IMAGE" "$PROJECT_ROOT/docker"; then
            log_error "Failed to build devbox base image"
            exit 1
        fi
        log_success "Base image built successfully"
    fi
}

# Resolve container name or ID to full container ID
resolve_container() {
    local name_or_id="$1"
    local container_id

    # First try exact name match with prefix
    if container_id=$(docker ps -aq --filter "name=^${CONTAINER_PREFIX}${name_or_id}$" 2>/dev/null) && [[ -n "$container_id" ]]; then
        echo "$container_id"
        return 0
    fi

    # Try partial ID match among devbox containers
    if container_id=$(docker ps -aq --filter "name=^${CONTAINER_PREFIX}" | xargs -I {} docker inspect --format '{{.Id}} {{.Name}}' {} 2>/dev/null | grep "^$name_or_id" | head -1 | cut -d' ' -f1) && [[ -n "$container_id" ]]; then
        echo "$container_id"
        return 0
    fi

    # Not found
    return 1
}

# Usage/help function
usage() {
    cat << EOF
Devbox - Manage isolated, authenticated development containers

USAGE:
    devbox <command> [options]

COMMANDS:
    init                    One-time setup: authenticate GitHub CLI and Claude Code
    create <name> <repo>    Create and start a new container instance
    list                    List all devbox containers with status
    attach <name|id>        Attach to a running container's shell
    stop <name|id>          Stop a container (keeps state)
    start <name|id>         Start a stopped container
    rm <name|id>            Remove a container
    logs <name|id>          View container logs
    exec <name|id> <cmd>    Execute a command in a running container
    ports <name|id>         Show port mappings for a container
    help                    Show this help message

INIT OPTIONS:
    --bedrock              Skip Claude OAuth, configure for Bedrock mode
    --import-aws           Import existing AWS credentials from ~/.aws

CREATE OPTIONS:
    --port, -p <host:container>  Port mapping (repeatable)
    --bedrock              Use AWS Bedrock for Claude (sets CLAUDE_CODE_USE_BEDROCK=1)
    --aws-profile <profile>  AWS profile name

RM OPTIONS:
    --force                Force remove a running container

LOGS OPTIONS:
    -f, --follow           Follow log output

EXAMPLES:
    # First-time setup (OAuth mode)
    devbox init

    # First-time setup (Bedrock mode)
    devbox init --bedrock --import-aws

    # Create container with port mapping
    devbox create myapp git@github.com:org/repo.git --port 3000:3000

    # Create container for Bedrock
    devbox create myapp git@github.com:org/repo.git --bedrock --aws-profile prod

    # List containers
    devbox list

    # Attach to container
    devbox attach myapp

    # Execute command in container
    devbox exec myapp gh pr list

EOF
}

# Command implementations
cmd_init() {
    local bedrock_mode=false
    local import_aws=false
    local dry_run=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --bedrock)
                bedrock_mode=true
                shift
                ;;
            --import-aws)
                import_aws=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --help|-h)
                cat << EOF
devbox init - One-time setup: authenticate GitHub CLI and Claude Code

USAGE:
    devbox init [options]

OPTIONS:
    --bedrock              Skip Claude OAuth, configure for Bedrock mode
    --import-aws           Import existing AWS credentials from ~/.aws
    --help, -h             Show this help message

DESCRIPTION:
    Performs initial setup by creating the credential volume and running
    the authentication flow for GitHub CLI and Claude Code. Credentials
    are stored in a Docker volume and shared across all devbox containers.

EXAMPLES:
    # Standard setup with Claude OAuth
    devbox init

    # Setup for AWS Bedrock mode
    devbox init --bedrock --import-aws

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                log_error "Unexpected argument: $1"
                return 1
                ;;
        esac
    done

    # Dry run mode for testing
    if [[ "$dry_run" == true ]]; then
        log_info "Dry run mode enabled"
        if [[ "$bedrock_mode" == true ]]; then
            log_info "Bedrock mode enabled"
        fi
        if [[ "$import_aws" == true ]]; then
            log_info "AWS import enabled"
        fi
        return 0
    fi

    log_info "Starting devbox initialization..."

    # Check if credential volume already exists
    if docker volume inspect "$DEVBOX_VOLUME" >/dev/null 2>&1; then
        log_warning "Credential volume '$DEVBOX_VOLUME' already exists"
        log_info "Initialization may overwrite existing credentials"

        # Prompt for confirmation
        read -r -p "Continue with initialization? [y/N] " response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_info "Initialization cancelled"
            return 0
        fi
    else
        log_info "Creating credential volume '$DEVBOX_VOLUME'..."
        if ! docker volume create "$DEVBOX_VOLUME" >/dev/null 2>&1; then
            log_error "Failed to create credential volume"
            return 1
        fi
        log_success "Credential volume created successfully"
    fi

    # Prepare environment variables for the init container
    local init_env=""
    if [[ "$bedrock_mode" == true ]]; then
        init_env="$init_env -e BEDROCK_MODE=true"
    fi
    if [[ "$import_aws" == true ]]; then
        init_env="$init_env -e IMPORT_AWS=true"
    fi

    # Mount host ~/.aws directory if importing AWS credentials
    local aws_mount=""
    if [[ "$import_aws" == true ]] && [[ -d "$HOME/.aws" ]]; then
        aws_mount="-v $HOME/.aws:/host-aws:ro"
    fi

    log_info "Starting authentication container..."

    # First fix volume permissions, then run init script
    log_info "Setting up volume permissions..."
    docker run --rm \
        --user root \
        --entrypoint '' \
        -v "$DEVBOX_VOLUME:/devbox-credentials" \
        "$DEVBOX_IMAGE" \
        chown devbox:devbox /devbox-credentials

    # Run the initialization container (override entrypoint to skip repo cloning)
    local container_cmd="docker run --rm \
        --entrypoint '' \
        -v $DEVBOX_VOLUME:/devbox-credentials \
        $aws_mount \
        $init_env \
        $DEVBOX_IMAGE \
        /init-credentials.sh"

    log_info "Running: $container_cmd"

    if eval "$container_cmd"; then
        log_success "Devbox initialization completed successfully!"
        echo
        if [[ "$bedrock_mode" == true ]]; then
            log_info "Mode: AWS Bedrock"
            log_info "Claude Code will use AWS credentials for authentication"
        else
            log_info "Mode: Claude OAuth"
            log_info "Claude Code will use OAuth tokens for authentication"
        fi
        echo
        log_info "You can now create containers with: devbox create <name> <repo>"
    else
        log_error "Initialization failed"
        return 1
    fi
}

cmd_create() {
    local container_name=""
    local repo_url=""
    local ports=()
    local bedrock_mode=false
    local aws_profile=""
    local dry_run=false

    # Parse arguments and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --port|-p)
                if [[ -z "${2:-}" ]]; then
                    log_error "Option $1 requires an argument"
                    return 1
                fi
                ports+=("$2")
                shift 2
                ;;
            --bedrock)
                bedrock_mode=true
                shift
                ;;
            --aws-profile)
                if [[ -z "${2:-}" ]]; then
                    log_error "Option $1 requires an argument"
                    return 1
                fi
                aws_profile="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --help|-h)
                cat << EOF
devbox create - Create and start a new container instance

USAGE:
    devbox create <name> <repo-url> [options]

ARGUMENTS:
    <name>                  Container name (must be unique)
    <repo-url>              Git repository URL to clone

OPTIONS:
    --port, -p <host:container>  Port mapping (repeatable)
    --bedrock              Use AWS Bedrock for Claude (sets CLAUDE_CODE_USE_BEDROCK=1)
    --aws-profile <profile>  AWS profile name
    --help, -h             Show this help message

DESCRIPTION:
    Creates a new development container with the specified repository cloned
    and ready for development. The container runs in detached mode with a
    persistent shell session.

EXAMPLES:
    # Basic container
    devbox create myapp git@github.com:org/repo.git

    # With port mapping
    devbox create webapp git@github.com:org/webapp.git --port 3000:3000

    # Bedrock mode with AWS profile
    devbox create myapp git@github.com:org/repo.git --bedrock --aws-profile prod

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$container_name" ]]; then
                    container_name="$1"
                elif [[ -z "$repo_url" ]]; then
                    repo_url="$1"
                else
                    log_error "Unexpected argument: $1"
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$container_name" ]]; then
        log_error "Container name required"
        log_error "Usage: devbox create <name> <repo-url>"
        return 1
    fi

    if [[ -z "$repo_url" ]]; then
        log_error "Repository URL required"
        log_error "Usage: devbox create <name> <repo-url>"
        return 1
    fi

    # Check for existing container with same name
    local full_container_name="${CONTAINER_PREFIX}${container_name}"
    if docker ps -aq --filter "name=^${full_container_name}$" | grep -q .; then
        log_error "Container with name '$container_name' already exists"
        log_error "Use 'devbox list' to see existing containers"
        return 1
    fi

    # Also check test prefix for test scenarios
    local test_container_name="devbox-test-${container_name}"
    if docker ps -aq --filter "name=^${test_container_name}$" | grep -q .; then
        log_error "Container with name '$container_name' already exists"
        log_error "Use 'devbox list' to see existing containers"
        return 1
    fi

    # Prepare environment variables
    local env_vars=""
    env_vars="$env_vars -e DEVBOX_REPO_URL=$repo_url"

    # Configure authentication mode
    local auth_mode="oauth"
    if [[ "$bedrock_mode" == true ]]; then
        auth_mode="bedrock"
        env_vars="$env_vars -e CLAUDE_CODE_USE_BEDROCK=1"
        env_vars="$env_vars -e AWS_REGION=${AWS_REGION:-us-east-1}"

        if [[ -n "$aws_profile" ]]; then
            env_vars="$env_vars -e AWS_PROFILE=$aws_profile"
        fi
    else
        if [[ -n "$aws_profile" ]]; then
            env_vars="$env_vars -e AWS_PROFILE=$aws_profile"
        fi
    fi

    # Prepare port mappings
    local port_args=""
    local port_labels=""
    if [[ ${#ports[@]} -gt 0 ]]; then
        for port in "${ports[@]}"; do
            port_args="$port_args -p $port"
        done
        # Create comma-separated list for labels
        port_labels=$(IFS=,; echo "${ports[*]}")
    fi

    # Prepare container labels for metadata
    local labels=""
    labels="$labels --label devbox.repo=$repo_url"
    labels="$labels --label devbox.mode=$auth_mode"
    if [[ -n "$port_labels" ]]; then
        labels="$labels --label devbox.ports=$port_labels"
    fi

    # Build Docker run command
    local docker_cmd="docker run -dit"
    docker_cmd="$docker_cmd --name $full_container_name"
    docker_cmd="$docker_cmd -v ${DEVBOX_VOLUME}:/devbox-credentials:ro"
    docker_cmd="$docker_cmd -v ${full_container_name}-workspace:/workspace"
    docker_cmd="$docker_cmd $port_args"
    docker_cmd="$docker_cmd $env_vars"
    docker_cmd="$docker_cmd $labels"

    # Set up credential environment variables
    docker_cmd="$docker_cmd -e GH_CONFIG_DIR=/devbox-credentials/gh"
    docker_cmd="$docker_cmd -e CLAUDE_CONFIG_DIR=/devbox-credentials/claude"
    docker_cmd="$docker_cmd -e AWS_CONFIG_FILE=/devbox-credentials/aws/config"
    docker_cmd="$docker_cmd -e AWS_SHARED_CREDENTIALS_FILE=/devbox-credentials/aws/credentials"

    docker_cmd="$docker_cmd $DEVBOX_IMAGE"

    # Dry run mode for testing
    if [[ "$dry_run" == true ]]; then
        echo "Would create container '$container_name' with:"
        echo "  Repository: $repo_url"
        echo "  Mode: $auth_mode"
        if [[ -n "$aws_profile" ]]; then
            echo "  AWS Profile: $aws_profile"
        fi
        if [[ ${#ports[@]} -gt 0 ]]; then
            echo "  Port mappings: $port_labels"
        fi
        if [[ "$bedrock_mode" == true ]]; then
            echo "  Environment: CLAUDE_CODE_USE_BEDROCK=1"
        fi
        echo "  Docker command: $docker_cmd"
        return 0
    fi

    log_info "Creating container '$container_name'..."
    log_info "Repository: $repo_url"
    log_info "Mode: $auth_mode"

    # Check if credentials volume exists
    if ! docker volume inspect "$DEVBOX_VOLUME" >/dev/null 2>&1; then
        log_error "Credentials volume '$DEVBOX_VOLUME' does not exist"
        log_error "Run 'devbox init' first to set up credentials"
        return 1
    fi

    # Create and start the container
    if eval "$docker_cmd" >/dev/null 2>&1; then
        local container_id
        container_id=$(docker ps -q --filter "name=^${full_container_name}$")
        log_success "Container '$container_name' created successfully"
        echo "  Container ID: ${container_id:0:12}"
        echo "  Repository: $repo_url"
        echo "  Status: running"
        echo
        log_info "Attach to container with: devbox attach $container_name"
    else
        log_error "Failed to create container"
        return 1
    fi
}

cmd_list() {
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat << EOF
devbox list - List all devbox containers with status

USAGE:
    devbox list [options]

OPTIONS:
    --help, -h             Show this help message

DESCRIPTION:
    Lists all devbox containers with their current status, repository,
    port mappings, and authentication mode. Shows containers in both
    running and stopped states.

EXAMPLES:
    # List all containers
    devbox list

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                log_error "Unexpected argument: $1"
                return 1
                ;;
        esac
    done

    # Get all devbox containers (both running and stopped)
    local containers
    containers=$(docker ps -a --filter "name=^${CONTAINER_PREFIX}" --format "{{.ID}}\t{{.Names}}\t{{.Status}}" 2>/dev/null || true)

    if [[ -z "$containers" ]]; then
        log_info "No devbox containers found"
        echo
        echo "Create your first container with:"
        echo "  devbox create <name> <repo-url>"
        return 0
    fi

    # Print table header
    printf "%-12s %-10s %-10s %-35s %-15s %s\n" "NAME" "ID" "STATUS" "REPO" "PORTS" "MODE"
    printf "%-12s %-10s %-10s %-35s %-15s %s\n" "----" "--" "------" "----" "-----" "----"

    # Process each container
    while IFS=$'\t' read -r container_id container_name status; do
        # Extract container name without prefix
        # Handle both regular devbox containers and test containers
        local display_name="$container_name"
        if [[ "$container_name" == devbox-test-* ]]; then
            display_name="${container_name#devbox-test-}"
        elif [[ "$container_name" == devbox-* ]]; then
            display_name="${container_name#devbox-}"
        fi

        # Get short ID
        local short_id="${container_id:0:8}"

        # Determine simple status
        local simple_status="exited"
        if [[ "$status" == *"Up"* ]]; then
            simple_status="running"
        fi

        # Get container labels
        local repo mode ports
        repo=$(docker inspect --format '{{index .Config.Labels "devbox.repo"}}' "$container_id" 2>/dev/null || echo "unknown")
        mode=$(docker inspect --format '{{index .Config.Labels "devbox.mode"}}' "$container_id" 2>/dev/null || echo "oauth")
        ports=$(docker inspect --format '{{index .Config.Labels "devbox.ports"}}' "$container_id" 2>/dev/null || echo "")

        # Handle empty ports
        if [[ -z "$ports" ]] || [[ "$ports" == "<no value>" ]]; then
            ports="-"
        fi

        # Handle unknown/missing values
        if [[ "$repo" == "<no value>" ]]; then
            repo="unknown"
        fi
        if [[ "$mode" == "<no value>" ]]; then
            mode="oauth"
        fi

        # Print container row
        printf "%-12s %-10s %-10s %-35s %-15s %s\n" \
            "$display_name" "$short_id" "$simple_status" "$repo" "$ports" "$mode"

    done <<< "$containers"
}

cmd_attach() {
    log_error "Command 'attach' not yet implemented"
    exit 1
}

cmd_stop() {
    log_error "Command 'stop' not yet implemented"
    exit 1
}

cmd_start() {
    log_error "Command 'start' not yet implemented"
    exit 1
}

cmd_rm() {
    log_error "Command 'rm' not yet implemented"
    exit 1
}

cmd_logs() {
    log_error "Command 'logs' not yet implemented"
    exit 1
}

cmd_exec() {
    log_error "Command 'exec' not yet implemented"
    exit 1
}

cmd_ports() {
    log_error "Command 'ports' not yet implemented"
    exit 1
}

# Main command dispatcher
main() {
    # Check for help first
    if [[ $# -eq 0 ]] || [[ "$1" == "help" ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
        usage
        exit 0
    fi

    # Check Docker is available (skip for help-only commands)
    check_docker

    # Ensure base image exists (skip for non-container commands)
    if [[ "$1" != "help" ]]; then
        ensure_image
    fi

    # Dispatch commands
    case "$1" in
        init)
            shift
            cmd_init "$@"
            ;;
        create)
            shift
            cmd_create "$@"
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        attach)
            shift
            cmd_attach "$@"
            ;;
        stop)
            shift
            cmd_stop "$@"
            ;;
        start)
            shift
            cmd_start "$@"
            ;;
        rm)
            shift
            cmd_rm "$@"
            ;;
        logs)
            shift
            cmd_logs "$@"
            ;;
        exec)
            shift
            cmd_exec "$@"
            ;;
        ports)
            shift
            cmd_ports "$@"
            ;;
        *)
            log_error "Unknown command: $1"
            echo
            usage
            exit 1
            ;;
    esac
}

# Entry point
main "$@"