#!/bin/bash
set -euo pipefail

# Devbox CLI - Manage isolated, authenticated development containers
# Version: 0.1.0

# Constants
readonly DEVBOX_IMAGE="devbox-base:latest"
readonly DEVBOX_VOLUME="devbox-credentials"
readonly CONTAINER_PREFIX="devbox-"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}INFO:${NC} $*"
}

log_success() {
    echo -e "${GREEN}✓${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $*"
}

log_error() {
    echo -e "${RED}✗${NC} $*" >&2
}

# Check if Docker is running
check_docker() {
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker is not running or not accessible"
        log_error "Please start Docker and try again"
        exit 1
    fi
}

# Build the base image if it doesn't exist
ensure_image() {
    if ! docker image inspect "$DEVBOX_IMAGE" >/dev/null 2>&1; then
        log_info "Building devbox base image..."
        if ! docker build -t "$DEVBOX_IMAGE" "$PROJECT_ROOT/docker"; then
            log_error "Failed to build devbox base image"
            exit 1
        fi
        log_success "Base image built successfully"
    fi
}

# Resolve container name or ID to full container ID
resolve_container() {
    local name_or_id="$1"
    local container_id

    # First try exact name match with production prefix
    if container_id=$(docker ps -aq --filter "name=^${CONTAINER_PREFIX}${name_or_id}$" 2>/dev/null) && [[ -n "$container_id" ]]; then
        echo "$container_id"
        return 0
    fi

    # Try exact name match with test prefix
    if container_id=$(docker ps -aq --filter "name=^devbox-test-${name_or_id}$" 2>/dev/null) && [[ -n "$container_id" ]]; then
        echo "$container_id"
        return 0
    fi

    # Try partial ID match among devbox containers (both prefixes)
    local all_containers
    all_containers=$(docker ps -aq --filter "name=^${CONTAINER_PREFIX}" && docker ps -aq --filter "name=^devbox-test-" 2>/dev/null | sort -u)
    if [[ -n "$all_containers" ]]; then
        if container_id=$(echo "$all_containers" | xargs -I {} docker inspect --format '{{.Id}} {{.Name}}' {} 2>/dev/null | grep "^$name_or_id" | head -1 | cut -d' ' -f1) && [[ -n "$container_id" ]]; then
            echo "$container_id"
            return 0
        fi
    fi

    # Not found
    return 1
}

# Usage/help function
usage() {
    cat << EOF
Devbox - Manage isolated, authenticated development containers

USAGE:
    devbox <command> [options]

COMMANDS:
    init                    One-time setup: authenticate GitHub CLI and Claude Code
    create <name> <repo>    Create and start a new container instance
    list                    List all devbox containers with status
    attach <name|id>        Attach to a running container's shell
    stop <name|id>          Stop a container (keeps state)
    start <name|id>         Start a stopped container
    rm <name|id>            Remove a container
    logs <name|id>          View container logs
    exec <name|id> <cmd>    Execute a command in a running container
    ports <name|id>         Show port mappings for a container
    help                    Show this help message

INIT OPTIONS:
    --bedrock              Skip Claude OAuth, configure for Bedrock mode
    --import-aws           Import existing AWS credentials from ~/.aws

CREATE OPTIONS:
    --port, -p <host:container>  Port mapping (repeatable)
    --bedrock              Use AWS Bedrock for Claude (sets CLAUDE_CODE_USE_BEDROCK=1)
    --aws-profile <profile>  AWS profile name

RM OPTIONS:
    --force                Force remove a running container

LOGS OPTIONS:
    -f, --follow           Follow log output

EXAMPLES:
    # First-time setup (OAuth mode)
    devbox init

    # First-time setup (Bedrock mode)
    devbox init --bedrock --import-aws

    # Create container with port mapping
    devbox create myapp git@github.com:org/repo.git --port 3000:3000

    # Create container for Bedrock
    devbox create myapp git@github.com:org/repo.git --bedrock --aws-profile prod

    # List containers
    devbox list

    # Attach to container
    devbox attach myapp

    # Execute command in container
    devbox exec myapp gh pr list

EOF
}

# Command implementations
cmd_init() {
    local bedrock_mode=false
    local import_aws=false
    local dry_run=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --bedrock)
                bedrock_mode=true
                shift
                ;;
            --import-aws)
                import_aws=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --help|-h)
                cat << EOF
devbox init - One-time setup: authenticate GitHub CLI and Claude Code

USAGE:
    devbox init [options]

OPTIONS:
    --bedrock              Skip Claude OAuth, configure for Bedrock mode
    --import-aws           Import existing AWS credentials from ~/.aws
    --help, -h             Show this help message

DESCRIPTION:
    Performs initial setup by creating the credential volume and running
    the authentication flow for GitHub CLI and Claude Code. Credentials
    are stored in a Docker volume and shared across all devbox containers.

EXAMPLES:
    # Standard setup with Claude OAuth
    devbox init

    # Setup for AWS Bedrock mode
    devbox init --bedrock --import-aws

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                log_error "Unexpected argument: $1"
                return 1
                ;;
        esac
    done

    # Dry run mode for testing
    if [[ "$dry_run" == true ]]; then
        log_info "Dry run mode enabled"
        if [[ "$bedrock_mode" == true ]]; then
            log_info "Bedrock mode enabled"
        fi
        if [[ "$import_aws" == true ]]; then
            log_info "AWS import enabled"
        fi
        return 0
    fi

    log_info "Starting devbox initialization..."

    # Check if credential volume already exists
    if docker volume inspect "$DEVBOX_VOLUME" >/dev/null 2>&1; then
        log_warning "Credential volume '$DEVBOX_VOLUME' already exists"
        log_info "Initialization may overwrite existing credentials"

        # Prompt for confirmation
        read -r -p "Continue with initialization? [y/N] " response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_info "Initialization cancelled"
            return 0
        fi
    else
        log_info "Creating credential volume '$DEVBOX_VOLUME'..."
        if ! docker volume create "$DEVBOX_VOLUME" >/dev/null 2>&1; then
            log_error "Failed to create credential volume"
            return 1
        fi
        log_success "Credential volume created successfully"
    fi

    # Prepare environment variables for the init container
    local init_env=""
    if [[ "$bedrock_mode" == true ]]; then
        init_env="$init_env -e BEDROCK_MODE=true"
    fi
    if [[ "$import_aws" == true ]]; then
        init_env="$init_env -e IMPORT_AWS=true"
    fi

    # Mount host ~/.aws directory if importing AWS credentials
    local aws_mount=""
    if [[ "$import_aws" == true ]] && [[ -d "$HOME/.aws" ]]; then
        aws_mount="-v $HOME/.aws:/host-aws:ro"
    fi

    log_info "Starting authentication container..."

    # First fix volume permissions, then run init script
    log_info "Setting up volume permissions..."
    docker run --rm \
        --user root \
        --entrypoint '' \
        -v "$DEVBOX_VOLUME:/devbox-credentials" \
        "$DEVBOX_IMAGE" \
        chown devbox:devbox /devbox-credentials

    # Run the initialization container (override entrypoint to skip repo cloning)
    local container_cmd="docker run --rm \
        --entrypoint '' \
        -v $DEVBOX_VOLUME:/devbox-credentials \
        $aws_mount \
        $init_env \
        $DEVBOX_IMAGE \
        /init-credentials.sh"

    log_info "Running: $container_cmd"

    if eval "$container_cmd"; then
        log_success "Devbox initialization completed successfully!"
        echo
        if [[ "$bedrock_mode" == true ]]; then
            log_info "Mode: AWS Bedrock"
            log_info "Claude Code will use AWS credentials for authentication"
        else
            log_info "Mode: Claude OAuth"
            log_info "Claude Code will use OAuth tokens for authentication"
        fi
        echo
        log_info "You can now create containers with: devbox create <name> <repo>"
    else
        log_error "Initialization failed"
        return 1
    fi
}

cmd_create() {
    local container_name=""
    local repo_url=""
    local ports=()
    local bedrock_mode=false
    local aws_profile=""
    local dry_run=false

    # Parse arguments and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --port|-p)
                if [[ -z "${2:-}" ]]; then
                    log_error "Option $1 requires an argument"
                    return 1
                fi
                ports+=("$2")
                shift 2
                ;;
            --bedrock)
                bedrock_mode=true
                shift
                ;;
            --aws-profile)
                if [[ -z "${2:-}" ]]; then
                    log_error "Option $1 requires an argument"
                    return 1
                fi
                aws_profile="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --help|-h)
                cat << EOF
devbox create - Create and start a new container instance

USAGE:
    devbox create <name> <repo-url> [options]

ARGUMENTS:
    <name>                  Container name (must be unique)
    <repo-url>              Git repository URL to clone

OPTIONS:
    --port, -p <host:container>  Port mapping (repeatable)
    --bedrock              Use AWS Bedrock for Claude (sets CLAUDE_CODE_USE_BEDROCK=1)
    --aws-profile <profile>  AWS profile name
    --help, -h             Show this help message

DESCRIPTION:
    Creates a new development container with the specified repository cloned
    and ready for development. The container runs in detached mode with a
    persistent shell session.

EXAMPLES:
    # Basic container
    devbox create myapp git@github.com:org/repo.git

    # With port mapping
    devbox create webapp git@github.com:org/webapp.git --port 3000:3000

    # Bedrock mode with AWS profile
    devbox create myapp git@github.com:org/repo.git --bedrock --aws-profile prod

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$container_name" ]]; then
                    container_name="$1"
                elif [[ -z "$repo_url" ]]; then
                    repo_url="$1"
                else
                    log_error "Unexpected argument: $1"
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$container_name" ]]; then
        log_error "Container name required"
        log_error "Usage: devbox create <name> <repo-url>"
        return 1
    fi

    if [[ -z "$repo_url" ]]; then
        log_error "Repository URL required"
        log_error "Usage: devbox create <name> <repo-url>"
        return 1
    fi

    # Check for existing container with same name
    local full_container_name="${CONTAINER_PREFIX}${container_name}"
    if docker ps -aq --filter "name=^${full_container_name}$" | grep -q .; then
        log_error "Container with name '$container_name' already exists"
        log_error "Use 'devbox list' to see existing containers"
        return 1
    fi

    # Also check test prefix for test scenarios
    local test_container_name="devbox-test-${container_name}"
    if docker ps -aq --filter "name=^${test_container_name}$" | grep -q .; then
        log_error "Container with name '$container_name' already exists"
        log_error "Use 'devbox list' to see existing containers"
        return 1
    fi

    # Prepare environment variables
    local env_vars=""
    env_vars="$env_vars -e DEVBOX_REPO_URL=$repo_url"

    # Configure authentication mode
    local auth_mode="oauth"
    if [[ "$bedrock_mode" == true ]]; then
        auth_mode="bedrock"
        env_vars="$env_vars -e CLAUDE_CODE_USE_BEDROCK=1"
        env_vars="$env_vars -e AWS_REGION=${AWS_REGION:-us-east-1}"

        if [[ -n "$aws_profile" ]]; then
            env_vars="$env_vars -e AWS_PROFILE=$aws_profile"
        fi
    else
        if [[ -n "$aws_profile" ]]; then
            env_vars="$env_vars -e AWS_PROFILE=$aws_profile"
        fi
    fi

    # Prepare port mappings
    local port_args=""
    local port_labels=""
    if [[ ${#ports[@]} -gt 0 ]]; then
        for port in "${ports[@]}"; do
            port_args="$port_args -p $port"
        done
        # Create comma-separated list for labels
        port_labels=$(IFS=,; echo "${ports[*]}")
    fi

    # Prepare container labels for metadata
    local labels=""
    labels="$labels --label devbox.repo=$repo_url"
    labels="$labels --label devbox.mode=$auth_mode"
    if [[ -n "$port_labels" ]]; then
        labels="$labels --label devbox.ports=$port_labels"
    fi

    # Build Docker run command
    local docker_cmd="docker run -dit"
    docker_cmd="$docker_cmd --name $full_container_name"
    docker_cmd="$docker_cmd -v ${DEVBOX_VOLUME}:/devbox-credentials:ro"
    docker_cmd="$docker_cmd -v ${full_container_name}-workspace:/workspace"
    docker_cmd="$docker_cmd $port_args"
    docker_cmd="$docker_cmd $env_vars"
    docker_cmd="$docker_cmd $labels"

    # Set up credential environment variables
    docker_cmd="$docker_cmd -e GH_CONFIG_DIR=/devbox-credentials/gh"
    docker_cmd="$docker_cmd -e CLAUDE_CONFIG_DIR=/devbox-credentials/claude"
    docker_cmd="$docker_cmd -e AWS_CONFIG_FILE=/devbox-credentials/aws/config"
    docker_cmd="$docker_cmd -e AWS_SHARED_CREDENTIALS_FILE=/devbox-credentials/aws/credentials"

    docker_cmd="$docker_cmd $DEVBOX_IMAGE"

    # Dry run mode for testing
    if [[ "$dry_run" == true ]]; then
        echo "Would create container '$container_name' with:"
        echo "  Repository: $repo_url"
        echo "  Mode: $auth_mode"
        if [[ -n "$aws_profile" ]]; then
            echo "  AWS Profile: $aws_profile"
        fi
        if [[ ${#ports[@]} -gt 0 ]]; then
            echo "  Port mappings: $port_labels"
        fi
        if [[ "$bedrock_mode" == true ]]; then
            echo "  Environment: CLAUDE_CODE_USE_BEDROCK=1"
        fi
        echo "  Docker command: $docker_cmd"
        return 0
    fi

    log_info "Creating container '$container_name'..."
    log_info "Repository: $repo_url"
    log_info "Mode: $auth_mode"

    # Check if credentials volume exists
    if ! docker volume inspect "$DEVBOX_VOLUME" >/dev/null 2>&1; then
        log_error "Credentials volume '$DEVBOX_VOLUME' does not exist"
        log_error "Run 'devbox init' first to set up credentials"
        return 1
    fi

    # Fix workspace volume permissions (similar to credentials volume fix in cmd_init)
    log_info "Setting up workspace volume permissions..."
    docker run --rm \
        --user root \
        --entrypoint '' \
        -v "${full_container_name}-workspace:/workspace" \
        "$DEVBOX_IMAGE" \
        chown devbox:devbox /workspace

    # Create and start the container
    if eval "$docker_cmd" >/dev/null 2>&1; then
        local container_id
        container_id=$(docker ps -q --filter "name=^${full_container_name}$")
        log_success "Container '$container_name' created successfully"
        echo "  Container ID: ${container_id:0:12}"
        echo "  Repository: $repo_url"
        echo "  Status: running"
        echo
        log_info "Attach to container with: devbox attach $container_name"
    else
        log_error "Failed to create container"
        return 1
    fi
}

cmd_list() {
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat << EOF
devbox list - List all devbox containers with status

USAGE:
    devbox list [options]

OPTIONS:
    --help, -h             Show this help message

DESCRIPTION:
    Lists all devbox containers with their current status, repository,
    port mappings, and authentication mode. Shows containers in both
    running and stopped states.

EXAMPLES:
    # List all containers
    devbox list

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                log_error "Unexpected argument: $1"
                return 1
                ;;
        esac
    done

    # Get all devbox containers (both running and stopped)
    local containers
    containers=$(docker ps -a --filter "name=^${CONTAINER_PREFIX}" --format "{{.ID}}\t{{.Names}}\t{{.Status}}" 2>/dev/null || true)

    if [[ -z "$containers" ]]; then
        log_info "No devbox containers found"
        echo
        echo "Create your first container with:"
        echo "  devbox create <name> <repo-url>"
        return 0
    fi

    # Print table header
    printf "%-12s %-10s %-10s %-35s %-15s %s\n" "NAME" "ID" "STATUS" "REPO" "PORTS" "MODE"
    printf "%-12s %-10s %-10s %-35s %-15s %s\n" "----" "--" "------" "----" "-----" "----"

    # Process each container
    while IFS=$'\t' read -r container_id container_name status; do
        # Extract container name without prefix
        # Handle both regular devbox containers and test containers
        local display_name="$container_name"
        if [[ "$container_name" == devbox-test-* ]]; then
            display_name="${container_name#devbox-test-}"
        elif [[ "$container_name" == devbox-* ]]; then
            display_name="${container_name#devbox-}"
        fi

        # Get short ID
        local short_id="${container_id:0:8}"

        # Determine simple status
        local simple_status="exited"
        if [[ "$status" == *"Up"* ]]; then
            simple_status="running"
        fi

        # Get container labels
        local repo mode ports
        repo=$(docker inspect --format '{{index .Config.Labels "devbox.repo"}}' "$container_id" 2>/dev/null || echo "unknown")
        mode=$(docker inspect --format '{{index .Config.Labels "devbox.mode"}}' "$container_id" 2>/dev/null || echo "oauth")
        ports=$(docker inspect --format '{{index .Config.Labels "devbox.ports"}}' "$container_id" 2>/dev/null || echo "")

        # Handle empty ports
        if [[ -z "$ports" ]] || [[ "$ports" == "<no value>" ]]; then
            ports="-"
        fi

        # Handle unknown/missing values
        if [[ "$repo" == "<no value>" ]]; then
            repo="unknown"
        fi
        if [[ "$mode" == "<no value>" ]]; then
            mode="oauth"
        fi

        # Print container row
        printf "%-12s %-10s %-10s %-35s %-15s %s\n" \
            "$display_name" "$short_id" "$simple_status" "$repo" "$ports" "$mode"

    done <<< "$containers"
}

cmd_attach() {
    local container_name=""
    local dry_run=false

    # Parse arguments and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --help|-h)
                cat << EOF
devbox attach - Attach to a running container's shell

USAGE:
    devbox attach <name|id> [options]

ARGUMENTS:
    <name|id>              Container name or ID to attach to

OPTIONS:
    --help, -h             Show this help message

DESCRIPTION:
    Attaches to a running container's shell session. The container must
    be running to attach to it. Use Ctrl+P, Ctrl+Q to detach without
    stopping the container.

EXAMPLES:
    # Attach to container by name
    devbox attach myproject

    # Attach to container by ID
    devbox attach a1b2c3d4

NOTES:
    - The container must be running to attach
    - Use Ctrl+P, Ctrl+Q to detach (standard Docker sequence)
    - The shell session persists when you detach

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$container_name" ]]; then
                    container_name="$1"
                else
                    log_error "Unexpected argument: $1"
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$container_name" ]]; then
        log_error "Container name or ID required"
        log_error "Usage: devbox attach <name|id>"
        return 1
    fi

    # Resolve container name to ID
    local container_id
    if ! container_id=$(resolve_container "$container_name"); then
        log_error "Container '$container_name' not found"
        log_error "Use 'devbox list' to see available containers"
        return 1
    fi

    # Check if container is running
    local container_status
    container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")

    if [[ "$container_status" != "running" ]]; then
        log_error "Container '$container_name' is not running (status: $container_status)"
        log_error "Start the container first with: devbox start $container_name"
        return 1
    fi

    # Get container display name for output
    local display_name
    display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
    if [[ "$display_name" == devbox-test-* ]]; then
        display_name="${display_name#devbox-test-}"
    elif [[ "$display_name" == devbox-* ]]; then
        display_name="${display_name#devbox-}"
    fi

    # Dry run mode for testing
    if [[ "$dry_run" == true ]]; then
        echo "Would attach to container '$display_name' (${container_id:0:12})"
        echo "Command: docker attach $container_id"
        echo
        echo "Note: Use Ctrl+P, Ctrl+Q to detach without stopping the container"
        return 0
    fi

    log_info "Attaching to container '$display_name' (${container_id:0:12})"
    log_info "Use Ctrl+P, Ctrl+Q to detach without stopping the container"
    echo

    # Attach to the container
    # The docker attach command will take over the terminal until detach
    if ! docker attach "$container_id"; then
        log_error "Failed to attach to container"
        return 1
    fi
}

cmd_stop() {
    local container_name=""
    local dry_run=false

    # Parse arguments and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --help|-h)
                cat << EOF
devbox stop - Stop a container (keeps state)

USAGE:
    devbox stop <name|id> [options]

ARGUMENTS:
    <name|id>              Container name or ID to stop

OPTIONS:
    --dry-run              Show what would be done without executing
    --help, -h             Show this help message

DESCRIPTION:
    Stops a running container, preserving its state. The container can be
    restarted later with 'devbox start'. If the container is already stopped,
    this command will succeed gracefully.

EXAMPLES:
    # Stop container by name
    devbox stop myproject

    # Stop container by ID
    devbox stop a1b2c3d4

NOTES:
    - Stopped containers retain their workspace and configuration
    - Use 'devbox start' to restart a stopped container
    - Use 'devbox rm' to permanently remove a container

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$container_name" ]]; then
                    container_name="$1"
                else
                    log_error "Too many arguments. Expected exactly 1 argument."
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$container_name" ]]; then
        log_error "Container name or ID is required"
        log_error "Usage: devbox stop <name|id>"
        return 1
    fi

    # Resolve container name to ID
    local container_id
    if ! container_id=$(resolve_container "$container_name"); then
        log_error "Container '$container_name' not found"
        log_error "Use 'devbox list' to see available containers"
        return 1
    fi

    # Get container display name for output
    local display_name
    display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
    if [[ "$display_name" == devbox-test-* ]]; then
        display_name="${display_name#devbox-test-}"
    elif [[ "$display_name" == devbox-* ]]; then
        display_name="${display_name#devbox-}"
    fi

    # Check current container status
    local container_status
    container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")

    # Dry run mode for testing
    if [[ "$dry_run" == true ]]; then
        echo "Would run: docker stop $container_id"
        echo "Container '$display_name' (${container_id:0:12}) current status: $container_status"
        return 0
    fi

    # If already stopped, report success
    if [[ "$container_status" == "exited" ]]; then
        log_success "Container '$display_name' is already stopped"
        return 0
    fi

    log_info "Stopping container '$display_name' (${container_id:0:12})"

    # Stop the container
    if docker stop "$container_id" >/dev/null 2>&1; then
        log_success "Container '$display_name' stopped successfully"
    else
        log_error "Failed to stop container '$display_name'"
        return 1
    fi
}

cmd_start() {
    local container_name=""
    local dry_run=false

    # Parse arguments and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --help|-h)
                cat << EOF
devbox start - Start a stopped container

USAGE:
    devbox start <name|id> [options]

ARGUMENTS:
    <name|id>              Container name or ID to start

OPTIONS:
    --dry-run              Show what would be done without executing
    --help, -h             Show this help message

DESCRIPTION:
    Starts a stopped container, preserving its configuration and workspace.
    If the container is already running, this command will succeed gracefully.
    The container will resume with all previous settings intact.

EXAMPLES:
    # Start container by name
    devbox start myproject

    # Start container by ID
    devbox start a1b2c3d4

NOTES:
    - Only stopped containers can be started
    - Running containers are handled gracefully
    - All previous configuration and workspace data is preserved
    - Use 'devbox attach' to connect to the started container

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$container_name" ]]; then
                    container_name="$1"
                else
                    log_error "Too many arguments. Expected exactly 1 argument."
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$container_name" ]]; then
        log_error "Container name or ID is required"
        log_error "Usage: devbox start <name|id>"
        return 1
    fi

    # Resolve container name to ID
    local container_id
    if ! container_id=$(resolve_container "$container_name"); then
        log_error "Container '$container_name' not found"
        log_error "Use 'devbox list' to see available containers"
        return 1
    fi

    # Get container display name for output
    local display_name
    display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
    if [[ "$display_name" == devbox-test-* ]]; then
        display_name="${display_name#devbox-test-}"
    elif [[ "$display_name" == devbox-* ]]; then
        display_name="${display_name#devbox-}"
    fi

    # Check current container status
    local container_status
    container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")

    # Dry run mode for testing
    if [[ "$dry_run" == true ]]; then
        echo "Would run: docker start $container_id"
        echo "Container '$display_name' (${container_id:0:12}) current status: $container_status"
        return 0
    fi

    # If already running, report success
    if [[ "$container_status" == "running" ]]; then
        log_success "Container '$display_name' is already running"
        return 0
    fi

    log_info "Starting container '$display_name' (${container_id:0:12})"

    # Start the container
    if docker start "$container_id" >/dev/null 2>&1; then
        log_success "Container '$display_name' started successfully"
    else
        log_error "Failed to start container '$display_name'"
        return 1
    fi
}

cmd_rm() {
    local container_name=""
    local force=false
    local dry_run=false

    # Parse arguments and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --help|-h)
                cat << EOF
devbox rm - Remove a container

USAGE:
    devbox rm <name|id> [options]

ARGUMENTS:
    <name|id>              Container name or ID to remove

OPTIONS:
    --force                Force remove a running container
    --dry-run              Show what would be done without executing
    --help, -h             Show this help message

DESCRIPTION:
    Permanently removes a container and its workspace. By default, only
    stopped containers can be removed. Use --force to remove running
    containers (they will be stopped first).

EXAMPLES:
    # Remove stopped container
    devbox rm myproject

    # Force remove running container
    devbox rm --force myproject

    # Remove container by ID
    devbox rm a1b2c3d4

NOTES:
    - This action is irreversible - all data will be lost
    - Running containers must be stopped first unless using --force
    - The workspace volume will be removed along with the container

EOF
                return 0
                ;;
            --*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                if [[ -z "$container_name" ]]; then
                    container_name="$1"
                else
                    log_error "Too many arguments. Expected exactly 1 argument."
                    return 1
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$container_name" ]]; then
        log_error "Container name or ID is required"
        log_error "Usage: devbox rm <name|id>"
        return 1
    fi

    # Resolve container name to ID
    local container_id
    if ! container_id=$(resolve_container "$container_name"); then
        log_error "Container '$container_name' not found"
        log_error "Use 'devbox list' to see available containers"
        return 1
    fi

    # Get container display name for output
    local display_name
    display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
    if [[ "$display_name" == devbox-test-* ]]; then
        display_name="${display_name#devbox-test-}"
    elif [[ "$display_name" == devbox-* ]]; then
        display_name="${display_name#devbox-}"
    fi

    # Check current container status
    local container_status
    container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")

    # Check if container is running and force flag not set
    if [[ "$container_status" == "running" ]] && [[ "$force" == false ]]; then
        log_error "Container '$display_name' is running"
        log_error "Stop it first with 'devbox stop $container_name' or use --force"
        return 1
    fi

    # Get workspace volume name for cleanup
    local workspace_volume
    workspace_volume=$(docker inspect --format '{{range .Mounts}}{{if eq .Destination "/workspace"}}{{.Name}}{{end}}{{end}}' "$container_id" 2>/dev/null || echo "")

    # Dry run mode for testing
    if [[ "$dry_run" == true ]]; then
        if [[ "$force" == true ]] && [[ "$container_status" == "running" ]]; then
            echo "Would run: docker rm -f $container_id"
        else
            echo "Would run: docker rm $container_id"
        fi
        echo "Container '$display_name' (${container_id:0:12}) current status: $container_status"
        if [[ -n "$workspace_volume" ]]; then
            echo "Would also run: docker volume rm $workspace_volume"
        fi
        return 0
    fi

    log_info "Removing container '$display_name' (${container_id:0:12})"

    # Remove the container (with force if needed and running)
    local rm_args=""
    if [[ "$force" == true ]] && [[ "$container_status" == "running" ]]; then
        rm_args="-f"
        log_info "Forcibly stopping and removing running container"
    fi

    if docker rm $rm_args "$container_id" >/dev/null 2>&1; then
        log_success "Container '$display_name' removed successfully"

        # Remove workspace volume if it exists
        if [[ -n "$workspace_volume" ]]; then
            log_info "Removing workspace volume '$workspace_volume'..."
            if docker volume rm "$workspace_volume" >/dev/null 2>&1; then
                log_success "Workspace volume removed successfully"
            else
                log_warning "Failed to remove workspace volume '$workspace_volume'"
            fi
        fi
    else
        log_error "Failed to remove container '$display_name'"
        return 1
    fi
}

cmd_logs() {
    log_error "Command 'logs' not yet implemented"
    exit 1
}

cmd_exec() {
    log_error "Command 'exec' not yet implemented"
    exit 1
}

cmd_ports() {
    log_error "Command 'ports' not yet implemented"
    exit 1
}

# Main command dispatcher
main() {
    # Check for help first
    if [[ $# -eq 0 ]] || [[ "$1" == "help" ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
        usage
        exit 0
    fi

    # Check Docker is available (skip for help-only commands)
    check_docker

    # Ensure base image exists (skip for non-container commands)
    if [[ "$1" != "help" ]]; then
        ensure_image
    fi

    # Dispatch commands
    case "$1" in
        init)
            shift
            cmd_init "$@"
            ;;
        create)
            shift
            cmd_create "$@"
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        attach)
            shift
            cmd_attach "$@"
            ;;
        stop)
            shift
            cmd_stop "$@"
            ;;
        start)
            shift
            cmd_start "$@"
            ;;
        rm)
            shift
            cmd_rm "$@"
            ;;
        logs)
            shift
            cmd_logs "$@"
            ;;
        exec)
            shift
            cmd_exec "$@"
            ;;
        ports)
            shift
            cmd_ports "$@"
            ;;
        *)
            log_error "Unknown command: $1"
            echo
            usage
            exit 1
            ;;
    esac
}

# Entry point
main "$@"