#!/bin/bash
set -euo pipefail

# Devbox CLI - Manage isolated, authenticated development containers
# Version: 0.1.0

# Constants
readonly DEVBOX_IMAGE="devbox-base:latest"
readonly DEVBOX_VOLUME="devbox-credentials"
readonly CONTAINER_PREFIX="devbox-"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Secrets directory (can be overridden via environment for testing)
DEVBOX_SECRETS_DIR="${DEVBOX_SECRETS_DIR:-$HOME/.devbox/secrets}"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() {
	echo -e "${BLUE}INFO:${NC} $*"
}

log_success() {
	echo -e "${GREEN}✓${NC} $*"
}

log_warning() {
	echo -e "${YELLOW}⚠${NC} $*"
}

log_error() {
	echo -e "${RED}✗${NC} $*" >&2
}

# Check if Docker is running
check_docker() {
	if ! docker info >/dev/null 2>&1; then
		log_error "Docker is not running or not accessible"
		log_error "Please start Docker and try again"
		exit 1
	fi
}

# Build the base image if it doesn't exist
ensure_image() {
	if ! docker image inspect "$DEVBOX_IMAGE" >/dev/null 2>&1; then
		log_info "Building devbox base image..."
		if ! docker build -t "$DEVBOX_IMAGE" "$PROJECT_ROOT/docker"; then
			log_error "Failed to build devbox base image"
			exit 1
		fi
		log_success "Base image built successfully"
	fi
}

# Resolve container name or ID to full container ID
resolve_container() {
	local name_or_id="$1"
	local container_id

	# First try exact name match with production prefix
	if container_id=$(docker ps -aq --filter "name=^${CONTAINER_PREFIX}${name_or_id}$" 2>/dev/null) && [[ -n "$container_id" ]]; then
		echo "$container_id"
		return 0
	fi

	# Try exact name match with test prefix
	if container_id=$(docker ps -aq --filter "name=^devbox-test-${name_or_id}$" 2>/dev/null) && [[ -n "$container_id" ]]; then
		echo "$container_id"
		return 0
	fi

	# Try partial ID match among devbox containers (both prefixes)
	local all_containers
	all_containers=$(docker ps -aq --filter "name=^${CONTAINER_PREFIX}" && docker ps -aq --filter "name=^devbox-test-" 2>/dev/null | sort -u)
	if [[ -n "$all_containers" ]]; then
		if container_id=$(echo "$all_containers" | xargs -I {} docker inspect --format '{{.Id}} {{.Name}}' {} 2>/dev/null | grep "^$name_or_id" | head -1 | cut -d' ' -f1) && [[ -n "$container_id" ]]; then
			echo "$container_id"
			return 0
		fi
	fi

	# Not found
	return 1
}

# Usage/help function
usage() {
	cat <<EOF
Devbox - Manage isolated, authenticated development containers

USAGE:
    devbox <command> [options]

COMMANDS:
    init                    One-time setup: authenticate Claude Code and AWS
    create <name> <repo>    Create and start a new container instance
    list                    List all devbox containers with status
    attach <name|id>        Attach to a running container's shell
    stop <name|id>          Stop a container (keeps state)
    start <name|id>         Start a stopped container
    rm <name|id>            Remove a container
    logs <name|id>          View container logs
    exec <name|id> <cmd>    Execute a command in a running container
    ports <name|id>         Show port mappings for a container
    secrets <subcommand>    Manage secrets (add, remove, list, path)
    help                    Show this help message

INIT OPTIONS:
    --bedrock              Skip Claude OAuth, configure for Bedrock mode
    --import-aws           Import existing AWS credentials from ~/.aws

CREATE OPTIONS:
    --port, -p <host:container>  Port mapping (repeatable)
    --secret <name>        Use stored secret for GITHUB_TOKEN
    --bedrock              Use AWS Bedrock for Claude (sets CLAUDE_CODE_USE_BEDROCK=1)
    --aws-profile <profile>  AWS profile name

RM OPTIONS:
    --force                Force remove a running container
    -f                     Force remove a running container
    -a                     Remove all devbox containers (with confirmation)
    -af, -fa               Remove all devbox containers including running ones

LOGS OPTIONS:
    -f, --follow           Follow log output

EXAMPLES:
    # First-time setup (OAuth mode)
    devbox init

    # First-time setup (Bedrock mode)
    devbox init --bedrock --import-aws

    # Store GitHub token as secret (one-time)
    export GITHUB_TOKEN="github_pat_xxx..."
    devbox secrets add github-token --from-env GITHUB_TOKEN

    # Create container using stored secret
    devbox create myapp org/repo --secret github-token --port 3000:3000

    # Create container for Bedrock
    devbox create myapp org/repo --secret github-token --bedrock --aws-profile prod

    # List containers
    devbox list

    # Attach to container
    devbox attach myapp

    # Execute command in container
    devbox exec myapp gh pr list

EOF
}

# Command implementations
cmd_init() {
	local bedrock_mode=false
	local import_aws=false
	local aws_profile=""
	local dry_run=false
	local force=false

	# Parse flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--bedrock)
			bedrock_mode=true
			shift
			;;
		--import-aws)
			import_aws=true
			shift
			;;
		--aws-profile)
			if [[ -z "${2:-}" ]]; then
				log_error "Option $1 requires an argument"
				return 1
			fi
			aws_profile="$2"
			shift 2
			;;
		--dry-run)
			dry_run=true
			shift
			;;
		--force)
			force=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox init - One-time setup: authenticate Claude Code and AWS

USAGE:
    devbox init [options]

OPTIONS:
    --bedrock              Skip Claude OAuth, configure for Bedrock mode
    --import-aws           Import existing AWS credentials from ~/.aws
    --aws-profile <name>   AWS profile to authenticate (requires --import-aws)
    --force                Force rebuild of Docker image even if it exists
    --help, -h             Show this help message

DESCRIPTION:
    Performs initial setup by creating the credential volume and running
    the authentication flow for Claude Code and AWS. Credentials are stored
    in a Docker volume and shared across all devbox containers.

    NOTE: GitHub authentication is now handled via GITHUB_TOKEN environment
    variable instead of OAuth. Create a fine-grained token at:
    GitHub → Settings → Developer settings → Fine-grained tokens

    Your existing ~/.claude/settings.json will be automatically imported.

    In Bedrock mode, AWS SSO profiles will be automatically detected and
    you'll be prompted to authenticate via device code flow.

EXAMPLES:
    # Standard setup with Claude OAuth
    devbox init

    # Setup for AWS Bedrock mode (authenticate all SSO profiles)
    devbox init --bedrock --import-aws

    # Setup for AWS Bedrock mode (authenticate specific profile)
    devbox init --bedrock --import-aws --aws-profile ascent

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			log_error "Unexpected argument: $1"
			return 1
			;;
		esac
	done

	# Dry run mode for testing
	if [[ "$dry_run" == true ]]; then
		log_info "Dry run mode enabled"
		if [[ "$bedrock_mode" == true ]]; then
			log_info "Bedrock mode enabled"
		fi
		if [[ "$import_aws" == true ]]; then
			log_info "AWS import enabled"
		fi
		return 0
	fi

	log_info "Starting devbox initialization..."

	# Force rebuild of Docker image if requested
	if [[ "$force" == true ]]; then
		log_info "Force mode: rebuilding Docker image..."
		if docker image inspect "$DEVBOX_IMAGE" >/dev/null 2>&1; then
			docker rmi -f "$DEVBOX_IMAGE" >/dev/null 2>&1 || true
		fi
		log_info "Building devbox base image..."
		if ! docker build -t "$DEVBOX_IMAGE" "$PROJECT_ROOT/docker"; then
			log_error "Failed to build devbox base image"
			return 1
		fi
		log_success "Base image rebuilt successfully"
	fi

	# Check if credential volume already exists
	if docker volume inspect "$DEVBOX_VOLUME" >/dev/null 2>&1; then
		log_warning "Credential volume '$DEVBOX_VOLUME' already exists"
		log_info "Initialization may overwrite existing credentials"

		# Prompt for confirmation
		read -r -p "Continue with initialization? [y/N] " response
		if [[ ! "$response" =~ ^[Yy]$ ]]; then
			log_info "Initialization cancelled"
			return 0
		fi
	else
		log_info "Creating credential volume '$DEVBOX_VOLUME'..."
		if ! docker volume create "$DEVBOX_VOLUME" >/dev/null 2>&1; then
			log_error "Failed to create credential volume"
			return 1
		fi
		log_success "Credential volume created successfully"
	fi

	# Prepare environment variables for the init container
	local init_env=""
	if [[ "$bedrock_mode" == true ]]; then
		init_env="$init_env -e BEDROCK_MODE=true"
	fi
	if [[ "$import_aws" == true ]]; then
		init_env="$init_env -e IMPORT_AWS=true"
	fi
	if [[ -n "$aws_profile" ]]; then
		init_env="$init_env -e AWS_SSO_PROFILE=$aws_profile"
	fi

	# Mount host ~/.aws directory if importing AWS credentials
	local aws_mount=""
	if [[ "$import_aws" == true ]] && [[ -d "$HOME/.aws" ]]; then
		aws_mount="-v $HOME/.aws:/host-aws:ro"
	fi

	# Mount host ~/.claude directory if settings.json or credentials exist for importing
	local claude_mount=""
	if [[ -f "$HOME/.claude/settings.json" ]] || [[ -f "$HOME/.claude/.credentials.json" ]]; then
		claude_mount="-v $HOME/.claude:/host-claude:ro"
	fi

	log_info "Starting authentication container..."

	# First fix volume permissions, then run init script
	log_info "Setting up volume permissions..."
	docker run --rm \
		--user root \
		--entrypoint '' \
		-v "$DEVBOX_VOLUME:/devbox-credentials" \
		"$DEVBOX_IMAGE" \
		chown devbox:devbox /devbox-credentials

	# Copy Claude credentials as root if they exist (to handle permission issues)
	if [[ -f "$HOME/.claude/.credentials.json" ]] || [[ -f "$HOME/.claude/settings.json" ]]; then
		log_info "Importing Claude credentials from host..."
		docker run --rm \
			--user root \
			--entrypoint '' \
			-v "$DEVBOX_VOLUME:/devbox-credentials" \
			-v "$HOME/.claude:/host-claude:ro" \
			"$DEVBOX_IMAGE" \
			bash -c 'mkdir -p /devbox-credentials/claude && \
                     if [ -f /host-claude/.credentials.json ]; then \
                         cp /host-claude/.credentials.json /devbox-credentials/claude/.credentials.json && \
                         echo "✓ Credentials copied"; \
                     fi && \
                     if [ -f /host-claude/settings.json ]; then \
                         cp /host-claude/settings.json /devbox-credentials/claude/settings.json && \
                         echo "✓ Settings copied"; \
                     fi && \
                     chown -R devbox:devbox /devbox-credentials/claude'
	fi

	# Run the initialization container (override entrypoint to skip repo cloning)
	local container_cmd="docker run --rm \
        --entrypoint '' \
        -v $DEVBOX_VOLUME:/devbox-credentials \
        $aws_mount \
        $claude_mount \
        $init_env \
        $DEVBOX_IMAGE \
        /init-credentials.sh"

	log_info "Running: $container_cmd"

	if eval "$container_cmd"; then
		log_success "Devbox initialization completed successfully!"
		echo
		if [[ "$bedrock_mode" == true ]]; then
			log_info "Mode: AWS Bedrock"
			log_info "Claude Code will use AWS credentials for authentication"
		else
			log_info "Mode: Claude OAuth"
			log_info "Claude Code will use OAuth tokens for authentication"
		fi
		echo
		log_info "You can now create containers with: devbox create <name> <repo>"
	else
		log_error "Initialization failed"
		return 1
	fi
}

cmd_create() {
	local container_name=""
	local repo_url=""
	local ports=()
	local bedrock_mode=false
	local aws_profile=""
	local dry_run=false
	local secrets=()

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--port | -p)
			if [[ -z "${2:-}" ]]; then
				log_error "Option $1 requires an argument"
				return 1
			fi
			ports+=("$2")
			shift 2
			;;
		--secret)
			if [[ -z "${2:-}" ]]; then
				log_error "Option $1 requires an argument"
				return 1
			fi
			secrets+=("$2")
			shift 2
			;;
		--bedrock)
			bedrock_mode=true
			shift
			;;
		--aws-profile)
			if [[ -z "${2:-}" ]]; then
				log_error "Option $1 requires an argument"
				return 1
			fi
			aws_profile="$2"
			shift 2
			;;
		--dry-run)
			dry_run=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox create - Create and start a new container instance

USAGE:
    devbox create <name> <repo> [options]

ARGUMENTS:
    <name>                  Container name (must be unique)
    <repo>                  Repository in format: owner/repo

OPTIONS:
    --port, -p <host:container>  Port mapping (repeatable)
    --secret <name>        Secret to inject (repeatable, mounted to /run/secrets/<name>)
                           First secret named 'github-token' is used for GitHub auth
    --bedrock              Use AWS Bedrock for Claude (sets CLAUDE_CODE_USE_BEDROCK=1)
    --aws-profile <profile>  AWS profile name
    --help, -h             Show this help message

ENVIRONMENT:
    GITHUB_TOKEN            GitHub personal access token (alternative to --secret)
                           Create at: GitHub → Settings → Developer settings → Tokens

DESCRIPTION:
    Creates a new development container with the specified repository cloned
    and ready for development. The container runs in detached mode with a
    persistent shell session.

    GitHub authentication can be provided via:
      1. --secret github-token: Read token from stored secret (recommended, secure)
      2. GITHUB_TOKEN environment variable

    Secrets are securely injected via file mounts to /run/secrets/<name>,
    not exposed as environment variables. The container reads them from files.

    To store a token as a secret:
      export GITHUB_TOKEN="github_pat_xxx..."
      devbox secrets add github-token --from-env GITHUB_TOKEN

EXAMPLES:
    # Using stored secret (recommended - secure file injection)
    devbox create myapp org/repo --secret github-token

    # Multiple secrets
    devbox create myapp org/repo --secret github-token --secret npm-token

    # With port mapping
    devbox create webapp org/webapp --secret github-token --port 3000:3000

    # Bedrock mode with AWS profile
    devbox create myapp org/repo --secret github-token --bedrock --aws-profile prod

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ -z "$container_name" ]]; then
				container_name="$1"
			elif [[ -z "$repo_url" ]]; then
				repo_url="$1"
			else
				log_error "Unexpected argument: $1"
				return 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$container_name" ]]; then
		log_error "Container name required"
		log_error "Usage: devbox create <name> <repo>"
		return 1
	fi

	if [[ -z "$repo_url" ]]; then
		log_error "Repository required (format: owner/repo)"
		log_error "Usage: devbox create <name> <repo>"
		return 1
	fi

	# Validate and prepare secrets
	local secrets_volume=""
	local github_token=""
	local use_secrets_volume=false
	local secret_values=()
	local secret_targets=()

	if [[ ${#secrets[@]} -gt 0 ]]; then
		use_secrets_volume=true
		secrets_volume="${CONTAINER_PREFIX}${container_name}-secrets"

		# Validate each secret and collect values
		for secret_name in "${secrets[@]}"; do
			local secret_path
			secret_path=$(get_secret_path "$secret_name")
			if [[ ! -f "$secret_path" ]]; then
				log_error "Secret '$secret_name' not found"
				echo ""
				echo "Available secrets:"
				if [[ -d "$DEVBOX_SECRETS_DIR" ]] && [[ -n "$(ls -A "$DEVBOX_SECRETS_DIR" 2>/dev/null)" ]]; then
					for f in "$DEVBOX_SECRETS_DIR"/*; do
						echo "  - $(basename "$f")"
					done
				else
					echo "  (none)"
				fi
				echo ""
				echo "Add a secret with:"
				echo "  devbox secrets add $secret_name --from-env YOUR_VAR"
				echo ""
				return 1
			fi

			local secret_value
			secret_value=$(cat "$secret_path")
			if [[ -z "$secret_value" ]]; then
				log_error "Secret '$secret_name' is empty"
				return 1
			fi

			# Map secret names to standard file names for container
			# github-token -> github_token (for entrypoint compatibility)
			local target_name="${secret_name//-/_}"

			# If this secret contains "github" in the name, also write it as github_token
			if [[ "$secret_name" == *github* ]] || [[ "$secret_name" == *GITHUB* ]]; then
				secret_values+=("$secret_value")
				secret_targets+=("github_token")
				github_token="from-secrets-volume"
			fi

			# Also store under the original name (normalized with underscores)
			secret_values+=("$secret_value")
			secret_targets+=("$target_name")
		done

		# Require a github token for repo cloning
		if [[ -z "$github_token" ]]; then
			log_error "A GitHub token secret is required for repository cloning"
			echo ""
			echo "Provide a secret containing 'github' in the name:"
			echo "  devbox create $container_name $repo_url --secret github-token"
			echo "  devbox create $container_name $repo_url --secret my-github-token"
			echo ""
			return 1
		fi
	elif [[ -n "${GITHUB_TOKEN:-}" ]]; then
		# Fallback to environment variable (less secure)
		github_token="$GITHUB_TOKEN"
	else
		log_error "GitHub token required: use --secret github-token or set GITHUB_TOKEN"
		echo ""
		echo "Option 1 - Use a stored secret (recommended - secure):"
		echo "  devbox secrets add github-token --from-env GITHUB_TOKEN"
		echo "  devbox create $container_name $repo_url --secret github-token"
		echo ""
		echo "Option 2 - Use environment variable (less secure):"
		echo "  export GITHUB_TOKEN=\"github_pat_xxx...\""
		echo "  devbox create $container_name $repo_url"
		echo ""
		echo "Create a fine-grained GitHub token at:"
		echo "  GitHub → Settings → Developer settings → Fine-grained tokens"
		echo ""
		return 1
	fi

	# Check for existing container with same name
	local full_container_name="${CONTAINER_PREFIX}${container_name}"
	if docker ps -aq --filter "name=^${full_container_name}$" | grep -q .; then
		log_error "Container with name '$container_name' already exists"
		log_error "Use 'devbox list' to see existing containers"
		return 1
	fi

	# Also check test prefix for test scenarios
	local test_container_name="devbox-test-${container_name}"
	if docker ps -aq --filter "name=^${test_container_name}$" | grep -q .; then
		log_error "Container with name '$container_name' already exists"
		log_error "Use 'devbox list' to see existing containers"
		return 1
	fi

	# Prepare environment variables
	local env_vars=""
	env_vars="$env_vars -e DEVBOX_REPO=$repo_url"

	# Only pass GITHUB_TOKEN via env var if NOT using secrets mount (less secure fallback)
	if [[ "$use_secrets_volume" != true ]]; then
		env_vars="$env_vars -e GITHUB_TOKEN=$github_token"
	fi

	# Configure authentication mode
	local auth_mode="oauth"
	if [[ "$bedrock_mode" == true ]]; then
		auth_mode="bedrock"
		env_vars="$env_vars -e CLAUDE_CODE_USE_BEDROCK=1"
		env_vars="$env_vars -e AWS_REGION=${AWS_REGION:-us-east-1}"

		if [[ -n "$aws_profile" ]]; then
			env_vars="$env_vars -e AWS_PROFILE=$aws_profile"
		fi
	else
		if [[ -n "$aws_profile" ]]; then
			env_vars="$env_vars -e AWS_PROFILE=$aws_profile"
		fi
	fi

	# Prepare port mappings
	local port_args=""
	local port_labels=""
	if [[ ${#ports[@]} -gt 0 ]]; then
		for port in "${ports[@]}"; do
			port_args="$port_args -p $port"
		done
		# Create comma-separated list for labels
		port_labels=$(
			IFS=,
			echo "${ports[*]}"
		)
	fi

	# Prepare container labels for metadata
	local labels=""
	labels="$labels --label devbox.repo=$repo_url"
	labels="$labels --label devbox.mode=$auth_mode"
	if [[ -n "$port_labels" ]]; then
		labels="$labels --label devbox.ports=$port_labels"
	fi

	# Detect Docker socket location (rootless vs root vs Colima)
	local docker_socket=""
	local docker_host_var=""
	local is_colima=false

	if [ -S "/run/user/$(id -u)/docker.sock" ]; then
		# Rootless Docker
		docker_socket="/run/user/$(id -u)/docker.sock"
		docker_host_var="unix:///var/run/docker.sock"
	elif [ -S "/var/run/docker.sock" ]; then
		# Root Docker
		docker_socket="/var/run/docker.sock"
		docker_host_var="unix:///var/run/docker.sock"
	elif [ -S "$HOME/.colima/default/docker.sock" ]; then
		# Colima Docker (macOS) - special handling needed
		is_colima=true
		docker_host_var="unix:///home/devbox/.colima/default/docker.sock"
	fi

	# Build Docker run command
	local docker_cmd="docker run -dit"
	docker_cmd="$docker_cmd --name $full_container_name"
	docker_cmd="$docker_cmd -v ${DEVBOX_VOLUME}:/devbox-credentials:ro"
	docker_cmd="$docker_cmd -v ${full_container_name}-workspace:/workspace"

	# Mount secrets volume if using secure secret injection
	if [[ "$use_secrets_volume" == true ]] && [[ -n "$secrets_volume" ]]; then
		docker_cmd="$docker_cmd -v ${secrets_volume}:/run/secrets:ro"
	fi

	# Mount Docker socket if available
	if [ -n "$docker_socket" ]; then
		docker_cmd="$docker_cmd -v ${docker_socket}:/var/run/docker.sock"
		docker_cmd="$docker_cmd -e DOCKER_HOST=${docker_host_var}"
	elif [ "$is_colima" = true ]; then
		# For Colima (macOS), use Docker-in-Docker since socket mounting doesn't work
		docker_cmd="$docker_cmd --privileged"
		docker_cmd="$docker_cmd -e DOCKER_TLS_CERTDIR="
		docker_cmd="$docker_cmd -e DEVBOX_DOCKER_IN_DOCKER=true"
		log_info "Using Docker-in-Docker for macOS/Colima compatibility"
	fi

	docker_cmd="$docker_cmd $port_args"
	docker_cmd="$docker_cmd $env_vars"
	docker_cmd="$docker_cmd $labels"

	# Set up credential environment variables
	docker_cmd="$docker_cmd -e GH_CONFIG_DIR=/devbox-credentials/gh"
	docker_cmd="$docker_cmd -e CLAUDE_CONFIG_DIR=/home/devbox/.claude"
	docker_cmd="$docker_cmd -e AWS_CONFIG_FILE=/devbox-credentials/aws/config"
	docker_cmd="$docker_cmd -e AWS_SHARED_CREDENTIALS_FILE=/devbox-credentials/aws/credentials"

	docker_cmd="$docker_cmd $DEVBOX_IMAGE"

	# Dry run mode for testing
	if [[ "$dry_run" == true ]]; then
		echo "Would create container '$container_name' with:"
		echo "  Repository: $repo_url"
		echo "  Mode: $auth_mode"
		if [[ ${#secrets[@]} -gt 0 ]]; then
			echo "  Secrets (mounted to /run/secrets):"
			for secret_name in "${secrets[@]}"; do
				echo "    - $secret_name"
			done
		else
			echo "  GitHub token: from environment"
		fi
		if [[ -n "$aws_profile" ]]; then
			echo "  AWS Profile: $aws_profile"
		fi
		if [[ ${#ports[@]} -gt 0 ]]; then
			echo "  Port mappings: $port_labels"
		fi
		if [[ "$bedrock_mode" == true ]]; then
			echo "  Environment: CLAUDE_CODE_USE_BEDROCK=1"
		fi
		# Show docker command (secrets paths are fine to show, values are in files)
		echo "  Docker command: $docker_cmd"
		return 0
	fi

	log_info "Creating container '$container_name'..."
	log_info "Repository: $repo_url"
	log_info "Mode: $auth_mode"

	# Check if credentials volume exists
	if ! docker volume inspect "$DEVBOX_VOLUME" >/dev/null 2>&1; then
		log_error "Credentials volume '$DEVBOX_VOLUME' does not exist"
		log_error "Run 'devbox init' first to set up credentials"
		return 1
	fi

	# Fix workspace volume permissions (similar to credentials volume fix in cmd_init)
	log_info "Setting up workspace volume permissions..."
	docker run --rm \
		--user root \
		--entrypoint '' \
		-v "${full_container_name}-workspace:/workspace" \
		"$DEVBOX_IMAGE" \
		chown devbox:devbox /workspace

	# Populate secrets volume if using secure secret injection
	if [[ "$use_secrets_volume" == true ]] && [[ -n "$secrets_volume" ]]; then
		log_info "Setting up secrets volume..."
		# Create volume and populate with secrets using correct ownership (devbox user)
		# We pipe secrets via stdin to avoid exposing them in process arguments
		local secrets_script=""
		for i in "${!secret_targets[@]}"; do
			local target="${secret_targets[$i]}"
			local value="${secret_values[$i]}"
			# Use base64 to safely pass values that might contain special chars
			local encoded
			encoded=$(echo -n "$value" | base64 -w0)
			secrets_script="${secrets_script}echo '$encoded' | base64 -d > /run/secrets/$target && chmod 600 /run/secrets/$target; "
		done
		secrets_script="${secrets_script}chown -R devbox:devbox /run/secrets"

		docker run --rm \
			--user root \
			--entrypoint '' \
			-v "${secrets_volume}:/run/secrets" \
			"$DEVBOX_IMAGE" \
			bash -c "$secrets_script"
	fi

	# Create and start the container
	if eval "$docker_cmd" >/dev/null 2>&1; then
		local container_id
		container_id=$(docker ps -q --filter "name=^${full_container_name}$")
		log_success "Container '$container_name' created successfully"
		echo "  Container ID: ${container_id:0:12}"
		echo "  Repository: $repo_url"
		echo "  Status: running"
		echo
		log_info "Attach to container with: devbox attach $container_name"
	else
		log_error "Failed to create container"
		return 1
	fi
}

cmd_list() {
	# Parse flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--help | -h)
			cat <<EOF
devbox list - List all devbox containers with status

USAGE:
    devbox list [options]

OPTIONS:
    --help, -h             Show this help message

DESCRIPTION:
    Lists all devbox containers with their current status, repository,
    port mappings, and authentication mode. Shows containers in both
    running and stopped states.

EXAMPLES:
    # List all containers
    devbox list

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			log_error "Unexpected argument: $1"
			return 1
			;;
		esac
	done

	# Get all devbox containers (both running and stopped)
	local containers
	containers=$(docker ps -a --filter "name=^${CONTAINER_PREFIX}" --format "{{.ID}}\t{{.Names}}\t{{.Status}}" 2>/dev/null || true)

	if [[ -z "$containers" ]]; then
		log_info "No devbox containers found"
		echo
		echo "Create your first container with:"
		echo "  devbox create <name> <repo-url>"
		return 0
	fi

	# Print table header
	printf "%-12s %-10s %-10s %-35s %-15s %s\n" "NAME" "ID" "STATUS" "REPO" "PORTS" "MODE"
	printf "%-12s %-10s %-10s %-35s %-15s %s\n" "----" "--" "------" "----" "-----" "----"

	# Process each container
	while IFS=$'\t' read -r container_id container_name status; do
		# Extract container name without prefix
		# Handle both regular devbox containers and test containers
		local display_name="$container_name"
		if [[ "$container_name" == devbox-test-* ]]; then
			display_name="${container_name#devbox-test-}"
		elif [[ "$container_name" == devbox-* ]]; then
			display_name="${container_name#devbox-}"
		fi

		# Get short ID
		local short_id="${container_id:0:8}"

		# Determine simple status
		local simple_status="exited"
		if [[ "$status" == *"Up"* ]]; then
			simple_status="running"
		fi

		# Get container labels
		local repo mode ports
		repo=$(docker inspect --format '{{index .Config.Labels "devbox.repo"}}' "$container_id" 2>/dev/null || echo "unknown")
		mode=$(docker inspect --format '{{index .Config.Labels "devbox.mode"}}' "$container_id" 2>/dev/null || echo "oauth")
		ports=$(docker inspect --format '{{index .Config.Labels "devbox.ports"}}' "$container_id" 2>/dev/null || echo "")

		# Handle empty ports
		if [[ -z "$ports" ]] || [[ "$ports" == "<no value>" ]]; then
			ports="-"
		fi

		# Handle unknown/missing values
		if [[ "$repo" == "<no value>" ]]; then
			repo="unknown"
		fi
		if [[ "$mode" == "<no value>" ]]; then
			mode="oauth"
		fi

		# Print container row
		printf "%-12s %-10s %-10s %-35s %-15s %s\n" \
			"$display_name" "$short_id" "$simple_status" "$repo" "$ports" "$mode"

	done <<<"$containers"
}

cmd_attach() {
	local container_name=""
	local dry_run=false

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--dry-run)
			dry_run=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox attach - Attach to a running container's shell

USAGE:
    devbox attach <name|id> [options]

ARGUMENTS:
    <name|id>              Container name or ID to attach to

OPTIONS:
    --help, -h             Show this help message

DESCRIPTION:
    Attaches to a running container's shell session. The container must
    be running to attach to it. Use Ctrl+P, Ctrl+Q to detach without
    stopping the container.

EXAMPLES:
    # Attach to container by name
    devbox attach myproject

    # Attach to container by ID
    devbox attach a1b2c3d4

NOTES:
    - The container must be running to attach
    - Use Ctrl+P, Ctrl+Q to detach (standard Docker sequence)
    - The shell session persists when you detach

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ -z "$container_name" ]]; then
				container_name="$1"
			else
				log_error "Unexpected argument: $1"
				return 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$container_name" ]]; then
		log_error "Container name or ID required"
		log_error "Usage: devbox attach <name|id>"
		return 1
	fi

	# Resolve container name to ID
	local container_id
	if ! container_id=$(resolve_container "$container_name"); then
		log_error "Container '$container_name' not found"
		log_error "Use 'devbox list' to see available containers"
		return 1
	fi

	# Check if container is running
	local container_status
	container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")

	if [[ "$container_status" != "running" ]]; then
		log_error "Container '$container_name' is not running (status: $container_status)"
		log_error "Start the container first with: devbox start $container_name"
		return 1
	fi

	# Get container display name for output
	local display_name
	display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
	if [[ "$display_name" == devbox-test-* ]]; then
		display_name="${display_name#devbox-test-}"
	elif [[ "$display_name" == devbox-* ]]; then
		display_name="${display_name#devbox-}"
	fi

	# Dry run mode for testing
	if [[ "$dry_run" == true ]]; then
		echo "Would attach to container '$display_name' (${container_id:0:12})"
		echo "Command: docker attach $container_id"
		echo
		echo "Note: Use Ctrl+P, Ctrl+Q to detach without stopping the container"
		return 0
	fi

	log_info "Attaching to container '$display_name' (${container_id:0:12})"
	log_info "Use Ctrl+P, Ctrl+Q to detach without stopping the container"
	echo

	# Attach to the container
	# The docker attach command will take over the terminal until detach
	if ! docker attach "$container_id"; then
		log_error "Failed to attach to container"
		return 1
	fi
}

cmd_stop() {
	local container_name=""
	local dry_run=false

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--dry-run)
			dry_run=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox stop - Stop a container (keeps state)

USAGE:
    devbox stop <name|id> [options]

ARGUMENTS:
    <name|id>              Container name or ID to stop

OPTIONS:
    --dry-run              Show what would be done without executing
    --help, -h             Show this help message

DESCRIPTION:
    Stops a running container, preserving its state. The container can be
    restarted later with 'devbox start'. If the container is already stopped,
    this command will succeed gracefully.

EXAMPLES:
    # Stop container by name
    devbox stop myproject

    # Stop container by ID
    devbox stop a1b2c3d4

NOTES:
    - Stopped containers retain their workspace and configuration
    - Use 'devbox start' to restart a stopped container
    - Use 'devbox rm' to permanently remove a container

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ -z "$container_name" ]]; then
				container_name="$1"
			else
				log_error "Too many arguments. Expected exactly 1 argument."
				return 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$container_name" ]]; then
		log_error "Container name or ID is required"
		log_error "Usage: devbox stop <name|id>"
		return 1
	fi

	# Resolve container name to ID
	local container_id
	if ! container_id=$(resolve_container "$container_name"); then
		log_error "Container '$container_name' not found"
		log_error "Use 'devbox list' to see available containers"
		return 1
	fi

	# Get container display name for output
	local display_name
	display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
	if [[ "$display_name" == devbox-test-* ]]; then
		display_name="${display_name#devbox-test-}"
	elif [[ "$display_name" == devbox-* ]]; then
		display_name="${display_name#devbox-}"
	fi

	# Check current container status
	local container_status
	container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")

	# Dry run mode for testing
	if [[ "$dry_run" == true ]]; then
		echo "Would run: docker stop $container_id"
		echo "Container '$display_name' (${container_id:0:12}) current status: $container_status"
		return 0
	fi

	# If already stopped, report success
	if [[ "$container_status" == "exited" ]]; then
		log_success "Container '$display_name' is already stopped"
		return 0
	fi

	log_info "Stopping container '$display_name' (${container_id:0:12})"

	# Stop the container
	if docker stop "$container_id" >/dev/null 2>&1; then
		log_success "Container '$display_name' stopped successfully"
	else
		log_error "Failed to stop container '$display_name'"
		return 1
	fi
}

cmd_start() {
	local container_name=""
	local dry_run=false

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--dry-run)
			dry_run=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox start - Start a stopped container

USAGE:
    devbox start <name|id> [options]

ARGUMENTS:
    <name|id>              Container name or ID to start

OPTIONS:
    --dry-run              Show what would be done without executing
    --help, -h             Show this help message

DESCRIPTION:
    Starts a stopped container, preserving its configuration and workspace.
    If the container is already running, this command will succeed gracefully.
    The container will resume with all previous settings intact.

EXAMPLES:
    # Start container by name
    devbox start myproject

    # Start container by ID
    devbox start a1b2c3d4

NOTES:
    - Only stopped containers can be started
    - Running containers are handled gracefully
    - All previous configuration and workspace data is preserved
    - Use 'devbox attach' to connect to the started container

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ -z "$container_name" ]]; then
				container_name="$1"
			else
				log_error "Too many arguments. Expected exactly 1 argument."
				return 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$container_name" ]]; then
		log_error "Container name or ID is required"
		log_error "Usage: devbox start <name|id>"
		return 1
	fi

	# Resolve container name to ID
	local container_id
	if ! container_id=$(resolve_container "$container_name"); then
		log_error "Container '$container_name' not found"
		log_error "Use 'devbox list' to see available containers"
		return 1
	fi

	# Get container display name for output
	local display_name
	display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
	if [[ "$display_name" == devbox-test-* ]]; then
		display_name="${display_name#devbox-test-}"
	elif [[ "$display_name" == devbox-* ]]; then
		display_name="${display_name#devbox-}"
	fi

	# Check current container status
	local container_status
	container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")

	# Dry run mode for testing
	if [[ "$dry_run" == true ]]; then
		echo "Would run: docker start $container_id"
		echo "Container '$display_name' (${container_id:0:12}) current status: $container_status"
		return 0
	fi

	# If already running, report success
	if [[ "$container_status" == "running" ]]; then
		log_success "Container '$display_name' is already running"
		return 0
	fi

	log_info "Starting container '$display_name' (${container_id:0:12})"

	# Start the container
	if docker start "$container_id" >/dev/null 2>&1; then
		log_success "Container '$display_name' started successfully"
	else
		log_error "Failed to start container '$display_name'"
		return 1
	fi
}

cmd_rm() {
	local container_name=""
	local force=false
	local all=false
	local dry_run=false

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--force)
			force=true
			shift
			;;
		--dry-run)
			dry_run=true
			shift
			;;
		-af | -fa)
			all=true
			force=true
			shift
			;;
		-a)
			all=true
			shift
			;;
		-f)
			force=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox rm - Remove a container

USAGE:
    devbox rm <name|id> [options]
    devbox rm -a [options]

ARGUMENTS:
    <name|id>              Container name or ID to remove

OPTIONS:
    --force, -f            Force remove (skip confirmation, stop running containers)
    -a                     Remove all devbox containers
    -af, -fa               Remove all devbox containers (force)
    --dry-run              Show what would be done without executing
    --help, -h             Show this help message

DESCRIPTION:
    Permanently removes a container and its workspace. By default, you will
    be prompted to confirm removal. Use --force/-f to skip confirmation and
    remove running containers (they will be stopped first). Use -a to remove
    all devbox containers.

EXAMPLES:
    # Remove stopped container (with confirmation)
    devbox rm myproject

    # Force remove without confirmation
    devbox rm --force myproject
    devbox rm -f myproject

    # Remove all containers (with confirmation)
    devbox rm -a

    # Remove all containers without confirmation
    devbox rm -af

    # Remove container by ID
    devbox rm a1b2c3d4

NOTES:
    - This action is irreversible - all data will be lost
    - Removal requires confirmation unless using --force/-f
    - Running containers must be stopped first unless using --force/-f
    - The workspace volume will be removed along with the container

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ "$all" == true ]]; then
				log_error "Cannot specify container name when using -a flag"
				return 1
			elif [[ -z "$container_name" ]]; then
				container_name="$1"
			else
				log_error "Too many arguments. Expected exactly 1 argument."
				return 1
			fi
			shift
			;;
		esac
	done

	# Handle -a (all) flag vs individual container
	if [[ "$all" == true ]]; then
		# Remove all devbox containers
		local all_containers
		all_containers=$(docker ps -aq --filter "name=^${CONTAINER_PREFIX}" 2>/dev/null || true)

		if [[ -z "$all_containers" ]]; then
			log_info "No devbox containers found to remove"
			return 0
		fi

		# Count containers
		local container_count
		container_count=$(echo "$all_containers" | wc -l | xargs)

		# Show what will be removed
		log_warning "This will remove ALL $container_count devbox containers and their workspaces:"
		echo
		while IFS= read -r container_id; do
			local display_name container_status
			display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "unknown")
			if [[ "$display_name" == devbox-test-* ]]; then
				display_name="${display_name#devbox-test-}"
			elif [[ "$display_name" == devbox-* ]]; then
				display_name="${display_name#devbox-}"
			fi
			container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")
			printf "  - %-15s (${container_id:0:12}) [%s]\n" "$display_name" "$container_status"
		done <<<"$all_containers"
		echo

		# Dry run mode
		if [[ "$dry_run" == true ]]; then
			echo "Dry run mode - would prompt for confirmation and remove all containers"
			if [[ "$force" == true ]]; then
				echo "Force mode enabled - would remove running containers"
			fi
			return 0
		fi

		# Confirmation prompt - require 'y'
		log_warning "This action is irreversible and will delete all data!"
		read -r -p "Type 'y' to confirm removal of all containers: " response
		if [[ "$response" != "y" ]]; then
			log_info "Operation cancelled"
			return 0
		fi

		# Remove each container
		local failed_count=0
		local success_count=0
		while IFS= read -r container_id; do
			local full_container_name display_name container_status workspace_volume
			full_container_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "unknown")
			display_name="$full_container_name"
			if [[ "$display_name" == devbox-test-* ]]; then
				display_name="${display_name#devbox-test-}"
			elif [[ "$display_name" == devbox-* ]]; then
				display_name="${display_name#devbox-}"
			fi
			container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")
			workspace_volume=$(docker inspect --format '{{range .Mounts}}{{if eq .Destination "/workspace"}}{{.Name}}{{end}}{{end}}' "$container_id" 2>/dev/null || echo "")

			# Check if container is running and force not set
			if [[ "$container_status" == "running" ]] && [[ "$force" == false ]]; then
				log_error "Skipping running container '$display_name' (use -af to force remove)"
				((failed_count++)) || true
				continue
			fi

			log_info "Removing container '$display_name' (${container_id:0:12})"

			# Remove the container
			local rm_args=""
			if [[ "$force" == true ]] && [[ "$container_status" == "running" ]]; then
				rm_args="-f"
			fi

			if docker rm $rm_args "$container_id" >/dev/null 2>&1; then
				log_success "Container '$display_name' removed"
				((success_count++)) || true

				# Remove workspace volume if it exists
				if [[ -n "$workspace_volume" ]]; then
					if docker volume rm "$workspace_volume" >/dev/null 2>&1; then
						log_info "Workspace volume removed for '$display_name'"
					else
						log_warning "Failed to remove workspace volume for '$display_name'"
					fi
				fi

				# Remove secrets volume if it exists
				local secrets_volume="${full_container_name}-secrets"
				if docker volume rm "$secrets_volume" >/dev/null 2>&1; then
					log_info "Secrets volume removed for '$display_name'"
				fi
			else
				log_error "Failed to remove container '$display_name'"
				((failed_count++)) || true
			fi
		done <<<"$all_containers"

		# Summary
		echo
		log_success "Removed $success_count container(s)"
		if [[ $failed_count -gt 0 ]]; then
			log_warning "$failed_count container(s) failed to remove"
			return 1
		fi

	else
		# Remove single container (original logic)
		# Validate required arguments
		if [[ -z "$container_name" ]]; then
			log_error "Container name or ID is required"
			log_error "Usage: devbox rm <name|id> or devbox rm -a"
			return 1
		fi

		# Resolve container name to ID
		local container_id
		if ! container_id=$(resolve_container "$container_name"); then
			log_error "Container '$container_name' not found"
			log_error "Use 'devbox list' to see available containers"
			return 1
		fi

		# Get container display name for output
		local display_name
		display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
		if [[ "$display_name" == devbox-test-* ]]; then
			display_name="${display_name#devbox-test-}"
		elif [[ "$display_name" == devbox-* ]]; then
			display_name="${display_name#devbox-}"
		fi

		# Check current container status
		local container_status
		container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")

		# Check if container is running and force flag not set
		if [[ "$container_status" == "running" ]] && [[ "$force" == false ]]; then
			log_error "Container '$display_name' is running"
			log_error "Stop it first with 'devbox stop $container_name' or use --force"
			return 1
		fi

		# Get workspace volume name for cleanup
		local workspace_volume
		workspace_volume=$(docker inspect --format '{{range .Mounts}}{{if eq .Destination "/workspace"}}{{.Name}}{{end}}{{end}}' "$container_id" 2>/dev/null || echo "")

		# Dry run mode for testing
		if [[ "$dry_run" == true ]]; then
			if [[ "$force" == true ]] && [[ "$container_status" == "running" ]]; then
				echo "Would run: docker rm -f $container_id"
			else
				echo "Would run: docker rm $container_id"
			fi
			echo "Container '$display_name' (${container_id:0:12}) current status: $container_status"
			if [[ -n "$workspace_volume" ]]; then
				echo "Would also run: docker volume rm $workspace_volume"
			fi
			return 0
		fi

		# Confirmation prompt unless --force is used
		if [[ "$force" == false ]]; then
			log_warning "This will remove container '$display_name' and its workspace"
			log_warning "This action is irreversible - all data will be lost!"
			read -r -p "Type 'y' to confirm removal: " response
			if [[ "$response" != "y" ]]; then
				log_info "Operation cancelled"
				return 0
			fi
		fi

		log_info "Removing container '$display_name' (${container_id:0:12})"

		# Remove the container (with force if needed and running)
		local rm_args=""
		if [[ "$force" == true ]] && [[ "$container_status" == "running" ]]; then
			rm_args="-f"
			log_info "Forcibly stopping and removing running container"
		fi

		# Get full container name before removal (for secrets cleanup)
		local full_container_name
		full_container_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "")

		if docker rm $rm_args "$container_id" >/dev/null 2>&1; then
			log_success "Container '$display_name' removed successfully"

			# Remove workspace volume if it exists
			if [[ -n "$workspace_volume" ]]; then
				log_info "Removing workspace volume '$workspace_volume'..."
				if docker volume rm "$workspace_volume" >/dev/null 2>&1; then
					log_success "Workspace volume removed successfully"
				else
					log_warning "Failed to remove workspace volume '$workspace_volume'"
				fi
			fi

			# Remove secrets volume if it exists
			if [[ -n "$full_container_name" ]]; then
				local secrets_volume="${full_container_name}-secrets"
				if docker volume rm "$secrets_volume" >/dev/null 2>&1; then
					log_info "Secrets volume removed"
				fi
			fi
		else
			log_error "Failed to remove container '$display_name'"
			return 1
		fi
	fi
}

cmd_logs() {
	local container_name=""
	local follow=false
	local tail_lines=""
	local dry_run=false

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--follow | -f)
			follow=true
			shift
			;;
		--tail)
			if [[ -z "${2:-}" ]]; then
				log_error "Option $1 requires an argument"
				return 1
			fi
			tail_lines="$2"
			shift 2
			;;
		--dry-run)
			dry_run=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox logs - View container logs

USAGE:
    devbox logs <name|id> [options]

ARGUMENTS:
    <name|id>              Container name or ID to view logs from

OPTIONS:
    -f, --follow           Follow log output (stream logs in real-time)
    --tail <lines>         Number of lines to show from the end of the logs
    --dry-run              Show what would be done without executing
    --help, -h             Show this help message

DESCRIPTION:
    Displays logs from a devbox container. Works with both running and
    stopped containers. Use --follow to stream logs in real-time (Ctrl+C
    to exit). Use --tail to limit output to recent log entries.

EXAMPLES:
    # View all logs
    devbox logs myproject

    # View last 50 lines
    devbox logs myproject --tail 50

    # Follow logs in real-time
    devbox logs myproject --follow
    devbox logs myproject -f

    # View logs by container ID
    devbox logs a1b2c3d4

NOTES:
    - Works with both running and stopped containers
    - Use Ctrl+C to exit when following logs
    - Logs are from the container's stdout and stderr

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ -z "$container_name" ]]; then
				container_name="$1"
			else
				log_error "Too many arguments. Expected exactly 1 argument."
				return 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$container_name" ]]; then
		log_error "Container name or ID is required"
		log_error "Usage: devbox logs <name|id>"
		return 1
	fi

	# Resolve container name to ID
	local container_id
	if ! container_id=$(resolve_container "$container_name"); then
		log_error "Container '$container_name' not found"
		log_error "Use 'devbox list' to see available containers"
		return 1
	fi

	# Get container display name for output
	local display_name
	display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
	if [[ "$display_name" == devbox-test-* ]]; then
		display_name="${display_name#devbox-test-}"
	elif [[ "$display_name" == devbox-* ]]; then
		display_name="${display_name#devbox-}"
	fi

	# Build docker logs command
	local docker_cmd="docker logs"

	if [[ "$follow" == true ]]; then
		docker_cmd="$docker_cmd -f"
	fi

	if [[ -n "$tail_lines" ]]; then
		docker_cmd="$docker_cmd --tail $tail_lines"
	fi

	docker_cmd="$docker_cmd $container_id"

	# Dry run mode for testing
	if [[ "$dry_run" == true ]]; then
		echo "Would run: $docker_cmd"
		echo "Container: '$display_name' (${container_id:0:12})"
		if [[ "$follow" == true ]]; then
			echo "Mode: following (streaming)"
		fi
		if [[ -n "$tail_lines" ]]; then
			echo "Tail: $tail_lines lines"
		fi
		return 0
	fi

	# Show info message unless following (to avoid cluttering output)
	if [[ "$follow" == false ]]; then
		log_info "Showing logs from '$display_name' (${container_id:0:12})"
		if [[ -n "$tail_lines" ]]; then
			log_info "Showing last $tail_lines lines"
		fi
		echo
	else
		log_info "Following logs from '$display_name' (${container_id:0:12}) - press Ctrl+C to exit"
		echo
	fi

	# Execute docker logs command
	if ! eval "$docker_cmd"; then
		log_error "Failed to retrieve logs from container"
		return 1
	fi
}

cmd_exec() {
	local container_name=""
	local exec_command=()
	local dry_run=false
	local interactive_flags=""

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		-it | -ti)
			interactive_flags="-it"
			shift
			;;
		--dry-run)
			dry_run=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox exec - Execute a command in a running container

USAGE:
    devbox exec <name|id> <command> [args...]

ARGUMENTS:
    <name|id>              Container name or ID to execute command in
    <command>              Command to execute
    [args...]              Arguments to pass to the command

OPTIONS:
    -it                    Run in interactive mode with TTY
    --dry-run              Show what would be done without executing
    --help, -h             Show this help message

DESCRIPTION:
    Executes a command in a running devbox container. The container must
    be running to execute commands. Use -it for interactive commands that
    require a terminal (like shells or interactive tools).

EXAMPLES:
    # Execute a simple command
    devbox exec myproject echo "hello world"

    # Run GitHub CLI command
    devbox exec myproject gh pr list

    # Check Claude version
    devbox exec myproject claude --version

    # Start an interactive shell
    devbox exec -it myproject bash

    # Run a command with multiple arguments
    devbox exec myproject sh -c "echo arg1 && echo arg2"

NOTES:
    - The container must be running to execute commands
    - Commands run with the same user and environment as the container
    - Use -it for interactive commands that need a terminal
    - Exit code of the command is propagated back

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ -z "$container_name" ]]; then
				container_name="$1"
				shift
			else
				# Everything else is the command and its arguments
				exec_command+=("$@")
				break
			fi
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$container_name" ]]; then
		log_error "Container name or ID is required"
		log_error "Usage: devbox exec <name|id> <command> [args...]"
		return 1
	fi

	if [[ ${#exec_command[@]} -eq 0 ]]; then
		log_error "Command is required"
		log_error "Usage: devbox exec <name|id> <command> [args...]"
		return 1
	fi

	# Resolve container name to ID
	local container_id
	if ! container_id=$(resolve_container "$container_name"); then
		log_error "Container '$container_name' not found"
		log_error "Use 'devbox list' to see available containers"
		return 1
	fi

	# Check if container is running
	local container_status
	container_status=$(docker inspect --format '{{.State.Status}}' "$container_id" 2>/dev/null || echo "unknown")

	if [[ "$container_status" != "running" ]]; then
		log_error "Container '$container_name' is not running (status: $container_status)"
		log_error "Start the container first with: devbox start $container_name"
		return 1
	fi

	# Get container display name for output
	local display_name
	display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
	if [[ "$display_name" == devbox-test-* ]]; then
		display_name="${display_name#devbox-test-}"
	elif [[ "$display_name" == devbox-* ]]; then
		display_name="${display_name#devbox-}"
	fi

	# Build docker exec command
	local docker_cmd="docker exec"

	if [[ -n "$interactive_flags" ]]; then
		docker_cmd="$docker_cmd $interactive_flags"
	fi

	docker_cmd="$docker_cmd $container_id"

	# Add the command and its arguments
	for arg in "${exec_command[@]}"; do
		# Properly quote arguments that contain spaces
		if [[ "$arg" =~ [[:space:]] ]]; then
			docker_cmd="$docker_cmd \"$arg\""
		else
			docker_cmd="$docker_cmd $arg"
		fi
	done

	# Dry run mode for testing
	if [[ "$dry_run" == true ]]; then
		echo "Would run: $docker_cmd"
		echo "Container: '$display_name' (${container_id:0:12})"
		echo "Command: ${exec_command[*]}"
		return 0
	fi

	# Execute the command in the container
	# We use eval to properly handle the command array
	eval "$docker_cmd"
}

cmd_ports() {
	local container_name=""
	local dry_run=false

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--dry-run)
			dry_run=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox ports - Show port mappings for a container

USAGE:
    devbox ports <name|id> [options]

ARGUMENTS:
    <name|id>              Container name or ID to show port mappings for

OPTIONS:
    --dry-run              Show what would be done without executing
    --help, -h             Show this help message

DESCRIPTION:
    Displays all port mappings for a devbox container, showing which host
    ports are mapped to which container ports. Works with both running and
    stopped containers.

EXAMPLES:
    # Show ports for a container
    devbox ports myproject

    # Show ports by container ID
    devbox ports a1b2c3d4

    # Dry-run mode
    devbox ports myproject --dry-run

NOTES:
    - Works with both running and stopped containers
    - Shows all TCP/UDP port mappings
    - Format: <host-port> -> <container-port>/<protocol>

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ -z "$container_name" ]]; then
				container_name="$1"
			else
				log_error "Too many arguments. Expected exactly 1 argument."
				return 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$container_name" ]]; then
		log_error "Container name or ID is required"
		log_error "Usage: devbox ports <name|id>"
		return 1
	fi

	# Resolve container name to ID
	local container_id
	if ! container_id=$(resolve_container "$container_name"); then
		log_error "Container '$container_name' not found"
		log_error "Use 'devbox list' to see available containers"
		return 1
	fi

	# Get container display name for output
	local display_name
	display_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | sed 's/^\///' || echo "$container_name")
	if [[ "$display_name" == devbox-test-* ]]; then
		display_name="${display_name#devbox-test-}"
	elif [[ "$display_name" == devbox-* ]]; then
		display_name="${display_name#devbox-}"
	fi

	# Dry run mode for testing
	if [[ "$dry_run" == true ]]; then
		echo "Would show ports for: '$display_name' (${container_id:0:12})"
		return 0
	fi

	# Get port mappings from HostConfig (works for both running and stopped containers)
	local ports
	ports=$(docker inspect --format '{{range $p, $conf := .HostConfig.PortBindings}}{{range $conf}}{{$p}} -> {{if .HostIp}}{{.HostIp}}{{else}}0.0.0.0{{end}}:{{.HostPort}}{{"\n"}}{{end}}{{end}}' "$container_id" 2>/dev/null)

	# Display results
	log_info "Port mappings for container '$display_name':"
	echo

	if [[ -z "$ports" ]]; then
		echo "No port mappings configured"
	else
		echo "$ports"
	fi
}

# ==============================================================================
# Secrets Management Commands
# ==============================================================================

# Validate secret name (alphanumeric, dashes, underscores only)
validate_secret_name() {
	local name="$1"
	if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
		return 1
	fi
	return 0
}

# Ensure secrets directory exists with proper permissions
ensure_secrets_dir() {
	if [[ ! -d "$DEVBOX_SECRETS_DIR" ]]; then
		mkdir -p "$DEVBOX_SECRETS_DIR"
		chmod 700 "$DEVBOX_SECRETS_DIR"
	fi
}

# Get path to a secret file
get_secret_path() {
	local name="$1"
	echo "$DEVBOX_SECRETS_DIR/$name"
}

cmd_secrets_add() {
	local secret_name=""
	local from_env=""
	local from_file=""
	local force=false

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--from-env)
			if [[ -z "${2:-}" ]]; then
				log_error "Option $1 requires an argument"
				return 1
			fi
			from_env="$2"
			shift 2
			;;
		--from-file)
			if [[ -z "${2:-}" ]]; then
				log_error "Option $1 requires an argument"
				return 1
			fi
			from_file="$2"
			shift 2
			;;
		--force | -f)
			force=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox secrets add - Add a secret to secure storage

USAGE:
    devbox secrets add <name> [options]

ARGUMENTS:
    <name>                  Secret name (alphanumeric, dashes, underscores only)

OPTIONS:
    --from-env <VAR>       Read secret value from environment variable
    --from-file <path>     Read secret value from file
    --force, -f            Overwrite existing secret without confirmation
    --help, -h             Show this help message

DESCRIPTION:
    Adds a secret to devbox's secure storage. Secrets are stored with restricted
    file permissions (600) in ~/.devbox/secrets/. Secret values are NEVER shown
    in command output or logs.

    You must specify either --from-env or --from-file to provide the secret value.
    Interactive input (prompting for value) is not supported to ensure secrets
    aren't accidentally logged or exposed.

EXAMPLES:
    # Add secret from environment variable
    export MY_TOKEN="secret-value"
    devbox secrets add github-token --from-env MY_TOKEN

    # Add secret from file
    devbox secrets add api-key --from-file ~/.secrets/api-key.txt

    # Overwrite existing secret
    devbox secrets add github-token --from-env NEW_TOKEN --force

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ -z "$secret_name" ]]; then
				secret_name="$1"
			else
				log_error "Unexpected argument: $1"
				return 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$secret_name" ]]; then
		log_error "Secret name is required"
		log_error "Usage: devbox secrets add <name> --from-env <VAR> or --from-file <path>"
		return 1
	fi

	# Validate secret name
	if ! validate_secret_name "$secret_name"; then
		log_error "Invalid secret name: '$secret_name'"
		log_error "Secret names must contain only alphanumeric characters, dashes, and underscores"
		return 1
	fi

	# Must specify source
	if [[ -z "$from_env" ]] && [[ -z "$from_file" ]]; then
		log_error "Must specify secret source with --from-env or --from-file"
		return 1
	fi

	# Can't specify both
	if [[ -n "$from_env" ]] && [[ -n "$from_file" ]]; then
		log_error "Cannot specify both --from-env and --from-file"
		return 1
	fi

	# Get secret value
	local secret_value=""
	if [[ -n "$from_env" ]]; then
		# Read from environment variable
		if [[ -z "${!from_env:-}" ]]; then
			log_error "Environment variable '$from_env' is not set or empty"
			return 1
		fi
		secret_value="${!from_env}"
	elif [[ -n "$from_file" ]]; then
		# Read from file
		if [[ ! -f "$from_file" ]]; then
			log_error "File does not exist: $from_file"
			return 1
		fi
		secret_value=$(cat "$from_file")
	fi

	# Ensure secrets directory exists
	ensure_secrets_dir

	# Check for existing secret
	local secret_path
	secret_path=$(get_secret_path "$secret_name")

	if [[ -f "$secret_path" ]]; then
		if [[ "$force" != true ]]; then
			log_error "Secret '$secret_name' already exists"
			log_error "Use --force to overwrite"
			return 1
		fi
		log_info "Overwriting existing secret '$secret_name'"
	fi

	# Write secret with restricted permissions
	# Use umask to ensure file is created with correct permissions
	(
		umask 077
		echo -n "$secret_value" >"$secret_path"
	)
	chmod 600 "$secret_path"

	log_success "Secret '$secret_name' added successfully"
}

cmd_secrets_remove() {
	local secret_name=""
	local force=false

	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--force | -f)
			force=true
			shift
			;;
		--help | -h)
			cat <<EOF
devbox secrets remove - Remove a secret from storage

USAGE:
    devbox secrets remove <name> [options]

ARGUMENTS:
    <name>                  Secret name to remove

OPTIONS:
    --force, -f            Skip confirmation prompt
    --help, -h             Show this help message

DESCRIPTION:
    Removes a secret from devbox's secure storage. By default, prompts for
    confirmation before removal. Use --force to skip the confirmation.

EXAMPLES:
    # Remove a secret (with confirmation)
    devbox secrets remove github-token

    # Remove without confirmation
    devbox secrets remove github-token --force

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			if [[ -z "$secret_name" ]]; then
				secret_name="$1"
			else
				log_error "Unexpected argument: $1"
				return 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$secret_name" ]]; then
		log_error "Secret name is required"
		log_error "Usage: devbox secrets remove <name>"
		return 1
	fi

	# Check if secret exists
	local secret_path
	secret_path=$(get_secret_path "$secret_name")

	if [[ ! -f "$secret_path" ]]; then
		log_error "Secret '$secret_name' does not exist"
		return 1
	fi

	# Confirm removal unless --force
	if [[ "$force" != true ]]; then
		read -r -p "Remove secret '$secret_name'? [y/N] " response
		if [[ ! "$response" =~ ^[Yy]$ ]]; then
			log_info "Operation cancelled"
			return 0
		fi
	fi

	# Remove the secret
	rm -f "$secret_path"
	log_success "Secret '$secret_name' removed successfully"
}

cmd_secrets_list() {
	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--help | -h)
			cat <<EOF
devbox secrets list - List all stored secrets

USAGE:
    devbox secrets list [options]

OPTIONS:
    --help, -h             Show this help message

DESCRIPTION:
    Lists all secrets stored in devbox's secure storage. Shows secret names
    only - secret values are NEVER displayed.

EXAMPLES:
    # List all secrets
    devbox secrets list

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			log_error "Unexpected argument: $1"
			return 1
			;;
		esac
	done

	# Ensure secrets directory exists
	ensure_secrets_dir

	# Check if any secrets exist
	if [[ ! -d "$DEVBOX_SECRETS_DIR" ]] || [[ -z "$(ls -A "$DEVBOX_SECRETS_DIR" 2>/dev/null)" ]]; then
		log_info "No secrets stored"
		echo
		echo "Add secrets with:"
		echo "  devbox secrets add <name> --from-env <VAR>"
		echo "  devbox secrets add <name> --from-file <path>"
		return 0
	fi

	# List secrets
	log_info "Stored secrets:"
	echo
	printf "%-30s %s\n" "NAME" "MODIFIED"
	printf "%-30s %s\n" "----" "--------"

	for secret_file in "$DEVBOX_SECRETS_DIR"/*; do
		if [[ -f "$secret_file" ]]; then
			local name modified
			name=$(basename "$secret_file")
			# Get modification time - cross-platform
			if stat --version &>/dev/null; then
				# GNU stat (Linux)
				modified=$(stat -c '%y' "$secret_file" 2>/dev/null | cut -d'.' -f1)
			else
				# BSD stat (macOS)
				modified=$(stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$secret_file" 2>/dev/null)
			fi
			printf "%-30s %s\n" "$name" "$modified"
		fi
	done
}

cmd_secrets_path() {
	# Parse arguments and flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--help | -h)
			cat <<EOF
devbox secrets path - Show the secrets storage directory

USAGE:
    devbox secrets path [options]

OPTIONS:
    --help, -h             Show this help message

DESCRIPTION:
    Displays the path to devbox's secrets storage directory.

EXAMPLES:
    # Show secrets path
    devbox secrets path

EOF
			return 0
			;;
		--*)
			log_error "Unknown option: $1"
			return 1
			;;
		*)
			log_error "Unexpected argument: $1"
			return 1
			;;
		esac
	done

	echo "$DEVBOX_SECRETS_DIR"
}

cmd_secrets() {
	# Parse arguments and flags
	if [[ $# -eq 0 ]]; then
		cat <<EOF
devbox secrets - Manage secrets for containers

USAGE:
    devbox secrets <subcommand> [options]

SUBCOMMANDS:
    add <name>             Add a secret to secure storage
    remove <name>          Remove a secret from storage
    list                   List all stored secrets
    path                   Show the secrets storage directory

OPTIONS:
    --help, -h             Show this help message

DESCRIPTION:
    Manages secrets that can be passed to containers. Secrets are stored
    with restricted permissions (600) and never displayed in output.

EXAMPLES:
    # Add a secret from environment variable
    export GITHUB_TOKEN="ghp_xxx..."
    devbox secrets add github-token --from-env GITHUB_TOKEN

    # List all secrets
    devbox secrets list

    # Remove a secret
    devbox secrets remove github-token

    # Show secrets directory
    devbox secrets path

For more information on a subcommand, run:
    devbox secrets <subcommand> --help

EOF
		return 0
	fi

	local subcommand="$1"
	shift

	case "$subcommand" in
	--help | -h)
		cmd_secrets
		return 0
		;;
	add)
		cmd_secrets_add "$@"
		;;
	remove | rm)
		cmd_secrets_remove "$@"
		;;
	list | ls)
		cmd_secrets_list "$@"
		;;
	path)
		cmd_secrets_path "$@"
		;;
	*)
		log_error "Unknown secrets subcommand: $subcommand"
		echo
		cmd_secrets
		return 1
		;;
	esac
}

# Main command dispatcher
main() {
	# Check for help first
	if [[ $# -eq 0 ]] || [[ "$1" == "help" ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
		usage
		exit 0
	fi

	# Handle secrets command early (doesn't require Docker)
	if [[ "$1" == "secrets" ]]; then
		shift
		cmd_secrets "$@"
		exit $?
	fi

	# Check Docker is available (skip for help-only commands)
	check_docker

	# Ensure base image exists (skip for non-container commands)
	if [[ "$1" != "help" ]]; then
		ensure_image
	fi

	# Dispatch commands
	case "$1" in
	init)
		shift
		cmd_init "$@"
		;;
	create)
		shift
		cmd_create "$@"
		;;
	list)
		shift
		cmd_list "$@"
		;;
	attach)
		shift
		cmd_attach "$@"
		;;
	stop)
		shift
		cmd_stop "$@"
		;;
	start)
		shift
		cmd_start "$@"
		;;
	rm)
		shift
		cmd_rm "$@"
		;;
	logs)
		shift
		cmd_logs "$@"
		;;
	exec)
		shift
		cmd_exec "$@"
		;;
	ports)
		shift
		cmd_ports "$@"
		;;
	*)
		log_error "Unknown command: $1"
		echo
		usage
		exit 1
		;;
	esac
}

# Entry point
main "$@"
